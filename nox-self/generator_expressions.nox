/**
* The kind of 'params' parameter of the routine.
*/
private enum Params_Kind {
  None,  // The routine has no 'params' parameter.
  Empty, // No arguments for the 'params' parameter are passed in.
  Pass,  // The single argument for 'params' parameter can just be passed as is (meaning it already is a slice).
  Fill,  // The arguments for the 'params' parameter have to be put into a slice which is then passed.
}

implement Generator {

  /**
  * Emit an expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @param type            The type of the expression.
  * @return The value of the expression.
  */
  internal proc emit_expression(routine_context: *Routine_Context, expression: *Expression, type: *Type) -> LLVMValueRef {
    self.debug_emit_location(routine_context, expression.position);

    type := type;
    if (type == null || type.is_any()) {
      type = self.get_resolved_type(expression);
    }

    switch (expression.kind) {
      case .Parenthesized: {
        expression := cast(*Expression_Parenthesized) expression;
        return self.emit_expression(routine_context, cast(*Expression) expression.expression, type);
      }

      case .Boolean: return self.emit_expression_boolean(expression, type);
      case .Integer: return self.emit_expression_integer(expression, type);
      case .Float: return self.emit_expression_float(expression, type);
      case .Character: return self.emit_expression_character(expression, type);
      case .String: return self.emit_expression_string(expression, type);
      case .Name: return self.emit_expression_name(routine_context, expression, type);

      case .Cast: return self.emit_expression_cast(routine_context, expression);
      case .Call: return self.emit_expression_call(routine_context, expression);
      case .Index: return self.emit_expression_index(routine_context, expression);
      case .Slice: return self.emit_expression_slice(routine_context, expression);
      case .Member: return self.emit_expression_member(routine_context, expression);
      case .Compound: return self.emit_expression_compound(routine_context, expression);
      case .Selector: return self.emit_expression_selector(routine_context, expression);
      case .Implicit_Selector: return self.emit_expression_implicit_selector(expression, type);

      case .Unary: return self.emit_expression_unary(routine_context, expression, type);
      case .Binary: return self.emit_expression_binary(routine_context, expression, type);
      case .Ternary: return self.emit_expression_ternary(routine_context, expression, type);
      case .Modify: return self.emit_expression_modify(routine_context, expression, type);

      case .Query: return self.emit_expression_query(routine_context, expression);
      case .Directive: return self.emit_expression_directive(routine_context, expression);

      case .None: fallthrough;
      case: assert(false);
    }

    assert(false);
    return null;
  }

  /**
  * Emit a boolean expression.
  * 
  * @param expression The expression to emit.
  * @param type       The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_boolean(expression: *Expression, type: *Type) -> LLVMValueRef {
    llvm_type := self.type_to_llvm(type);
    return LLVMConstInt(llvm_type, cast(u64) (cast(*Expression_Literal) expression).value.(bool), false);
  }

  /**
  * Emit an integer expression.
  * 
  * @param expression The expression to emit.
  * @param type       The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_integer(expression: *Expression, type: *Type) -> LLVMValueRef {
    llvm_type := self.type_to_llvm(type);
    if (type.is_float()) {
      return LLVMConstReal(llvm_type, cast(f64) (cast(*Expression_Literal) expression).value.(u64));  
    } else {
      return LLVMConstInt(llvm_type, (cast(*Expression_Literal) expression).value.(u64), false);
    }
  }

  /**
  * Emit a float expression.
  * 
  * @param expression The expression to emit.
  * @param type       The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_float(expression: *Expression, type: *Type) -> LLVMValueRef {
    // We cannot use self.constant_to_llvm here as it expects the Value to be in the right type and not just f64.
    llvm_type := self.type_to_llvm(type);
    return LLVMConstReal(llvm_type, (cast(*Expression_Literal) expression).value.(f64));
  }

  /**
  * Emit a character expression.
  * 
  * @param expression The expression to emit.
  * @param type       The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_character(expression: *Expression, type: *Type) -> LLVMValueRef {
    llvm_type := self.type_to_llvm(type);
    return LLVMConstInt(llvm_type, cast(u64) (cast(*Expression_Literal) expression).value.(char), false);
  }

  /**
  * Emit a string expression.
  * 
  * @param generator  The reference to the generator.
  * @param expression The expression to emit.
  * @param type       The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_string(expression: *Expression, type: *Type) -> LLVMValueRef {
    value := (cast(*Expression_Literal) expression).value.(string);
    llvm_string := self.string_to_llvm(value, type.is_cstring());
    return llvm_string; 
  }

  /**
  * Emit a name expression.
  * 
  * @param generator  The reference to the generator.
  * @param expression The expression to emit.
  * @param type       The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_name(routine_context: *Routine_Context, expression: *Expression, type: *Type) -> LLVMValueRef {
    name := (cast(*Expression_Name) expression).name;
    symbol := self.get_resolved_symbol(expression);
    return self.emit_expression_name_symbol(routine_context, expression, type, name, symbol);
  }

  /**
  * Emit a name expression for a symbol.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @param type            The type of the expression.
  * @param name            The name of the symbol.
  * @param symbol          The symbol corresponding to the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_name_symbol(routine_context: *Routine_Context, expression: *Expression, type: *Type, name: string, symbol: *Symbol) -> LLVMValueRef {
    // Emitting the correct named symbol is a little bit involved.
    //   1. Check for a constant which we can directly emit as is.
    //   2. Look for a local symbol.
    //   3. If the local is a parameter handle it accordingly.
    //   4. If no local symbol (or paramter) was found look for a global.

    routine_context.last_resolved_symbol_name = name;
    routine_context.last_resolved_symbol_was_parameter = false;

    // We directly generate values for constants. 
    // This also includes predefined constants like: true, false or null.
    if (symbol != null && symbol.kind == .Constant) {
      return self.constant_to_llvm(symbol.value, type);
    }

    llvm_name_value: LLVMValueRef;
    symbol_type: *Type;

    // First look for locals and parameters.
    llvm_local_symbol, found_local := self.get_local_symbol(routine_context, name);
    if (found_local) {
      llvm_name_value = llvm_local_symbol.llvm_value;
      symbol_type = llvm_local_symbol.type;

      if (llvm_local_symbol.is_parameter) {
        // We have to be careful here as not all parameters are being passed as expected.
        // Parameters that are being passed by value are actually being passed by pointer which needs to loaded first.
        // (Unless we explictily require the raw address from it).

        routine_context.last_resolved_symbol_was_parameter = true;

        if (routine_context.current_loading_mode == .Load_Address) {
          return llvm_name_value;
        } else if (self.type_is_passed_as_pointer(llvm_local_symbol.type)) {
          return self.emit_load(routine_context, llvm_local_symbol.type, llvm_name_value);
        } else {
          return llvm_name_value;
        }
      }
    }

    // Here we are looking for globals.
    if (!found_local) {
      symbol := self.get_resolved_symbol(expression);
      llvm_name_value = self.symbol_to_llvm(symbol);
      symbol_type = symbol.type;
    }

    return self.emit_expression_name_load_symbol(routine_context, symbol, symbol_type, llvm_name_value);
  }

  /**
  * Emit a name expression loading from a symbol.
  * 
  * @param routine_context The context of the routine.
  * @param symbol          The symbol to load from.
  * @param type            The type of the expression.
  * @param llvm_value      The LLVM value to load.
  * @return The value of the expression.
  */
  private proc emit_expression_name_load_symbol(routine_context: *Routine_Context, symbol: *Symbol, type: *Type, llvm_value: LLVMValueRef) -> LLVMValueRef {
    // There are a few cases where we want to return the name_value directly.
    //   1. Routines as they are always represented as pointers.
    //   2. We require it based on the current loading mode.

    if (symbol != null && symbol.kind == .Routine) {
      return llvm_value;
    } else if (routine_context.current_loading_mode == .Load_Address) {
      return llvm_value;
    }

    // For every other case (a regular local or global), we load the value.
    return self.emit_load(routine_context, type, llvm_value);
  }

  /**
  * Emit a cast expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_cast(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    llvm_value := self.emit_cast_expression(routine_context, expression);

    if (routine_context.current_loading_mode == .Load_Address) {
      type := self.get_resolved_type(expression);
      llvm_temporary := self.emit_temporary(routine_context, type, make_temp_name(routine_context));
      self.emit_store(routine_context, type, llvm_temporary, llvm_value, expression);
      // This is to allow for expressions like '(cast(*Foo) bar).foo' where 'bar' refers to a parameter.
      routine_context.last_resolved_symbol_was_parameter = false;
      return llvm_temporary;
    } else {
      return llvm_value;
    }
  }

  /**
  * Emit a call expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_call(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    expression := cast(*Expression_Call) expression;

    type := cast(*Type_Routine) self.get_resolved_type(cast(*Expression) expression.expression);

    if (has_flag(type.routine_flags, .Is_Intrinsic)) {
      return self.emit_expression_call_intrinsic(routine_context, expression);
    } else {
      return self.emit_expression_call_regular(routine_context, expression);
    }
  }

  /**
  * Emit a call expression to an intrinsic routine.
  * 
  * @param routine_context The context of the routine.
  * @param expression_call The call expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_call_intrinsic(routine_context: *Routine_Context, expression: *Expression_Call) -> LLVMValueRef {
    symbol := self.get_resolved_symbol(cast(*Expression) expression.expression);
    assert(symbol != null);

    // Manually reset the last resolved symbol (as it was the intrinsic routine).
    defer routine_context.last_resolved_symbol_was_parameter = false;

    intrinsic_routine, intrinsic_found := map_get(&INTRINSIC_ROUTINES, symbol.name);
    assert(intrinsic_found);
    switch (intrinsic_routine) {
      case .Entry_Point: {
        llvm_arguments := array_make!(LLVMValueRef)(0, 1, context.temporary_allocator);
        self.emit_expression_call_regular_context_pointer_argument(routine_context, &llvm_arguments);
        llvm_entry_point_type := self.type_to_llvm_without_routine_promotion(self.user_entry_point.type);
        llvm_entry_point := self.symbol_to_llvm(self.user_entry_point);
        return LLVMBuildCall2(self.builder, llvm_entry_point_type, llvm_entry_point, data(llvm_arguments), cast(u32) length(llvm_arguments), "");
      }
      case .Data: {
        assert(length(expression.arguments) == 1);
        
        argument_expression := expression.arguments[0];
        argument_type := self.get_resolved_type(argument_expression);

        previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
        llvm_argument := self.emit_expression(routine_context, argument_expression, argument_type);
        self.leave_loading_mode(routine_context, previous_loading_mode);

        // We automatically dereference pointers.
        needs_to_dereference_pointer := argument_type.is_absolute_pointer() || argument_type.is_self_relative_pointer();
        if (needs_to_dereference_pointer) {
          pointer_type := argument_type;
          argument_type = argument_type.base;

          if (pointer_type.is_absolute_pointer()) {
            // We exclude special cases were we do not actually need to load the pointer we got from the expression.
            if (!routine_context.last_resolved_symbol_was_parameter && argument_expression.kind != .Unary) {
              llvm_argument = self.emit_load(routine_context, pointer_type, llvm_argument);
            }
          } else if (pointer_type.is_self_relative_pointer()) {
            llvm_argument = self.emit_self_relative_pointer_to_absolute(routine_context, pointer_type, llvm_argument);
          }
        }

        if (argument_type.is_array()) {
          return llvm_argument;
        }

        llvm_slice_data_pointer := self.emit_gep_value_data(self.builder, routine_context, self.type_to_llvm(argument_type), llvm_argument);
        if (routine_context.current_loading_mode == .Load_Address) {
          return llvm_slice_data_pointer;
        } else {
          return self.emit_load(routine_context, context.storage.type_rawptr, llvm_slice_data_pointer);
        }
      }
      case .Length: {
        constant, found := self.get_resolved_constant(cast(*Expression) expression);
        if (found) {
          return LLVMConstInt(LLVMInt64Type(), cast(u64) constant.value.(int), false);
        }

        assert(length(expression.arguments) == 1);
        
        argument_expression := expression.arguments[0];
        argument_type := self.get_resolved_type(argument_expression);

        previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
        llvm_argument := self.emit_expression(routine_context, argument_expression, argument_type);
        self.leave_loading_mode(routine_context, previous_loading_mode);
        
        // We automatically dereference pointers.
        needs_to_dereference_pointer := argument_type.is_absolute_pointer() || argument_type.is_self_relative_pointer();
        if (needs_to_dereference_pointer) {
          pointer_type := argument_type;
          argument_type = argument_type.base;

          if (pointer_type.is_absolute_pointer()) {
            // We exclude special cases were we do not actually need to load the pointer we got from the expression.
            if (!routine_context.last_resolved_symbol_was_parameter && argument_expression.kind != .Unary) {
              llvm_argument = self.emit_load(routine_context, pointer_type, llvm_argument);
            }
          } else if (pointer_type.is_self_relative_pointer()) {
            llvm_argument = self.emit_self_relative_pointer_to_absolute(routine_context, pointer_type, llvm_argument);
          }
        }

        llvm_argument_type := self.type_to_llvm(argument_type);
        llvm_length_pointer: LLVMValueRef;
        if (argument_type.is_soa_or_aosoa()) {
          llvm_length_pointer = self.emit_gep_layout_collection_length(self.builder, routine_context, argument_type, llvm_argument_type, llvm_argument);
        } else {
          llvm_length_pointer = self.emit_gep_value_length(self.builder, routine_context, llvm_argument_type, llvm_argument);
        }
        
        if (routine_context.current_loading_mode == .Load_Address) {
          return llvm_length_pointer;
        } else {
          return self.emit_load(routine_context, context.storage.type_int, llvm_length_pointer);
        }
      }
      case .Capacity: {
        assert(length(expression.arguments) == 1);
        
        argument_expression := expression.arguments[0];
        argument_type := self.get_resolved_type(argument_expression);

        previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
        llvm_argument := self.emit_expression(routine_context, argument_expression, argument_type);
        self.leave_loading_mode(routine_context, previous_loading_mode);

        // We automatically dereference pointers.
        needs_to_dereference_pointer := argument_type.is_absolute_pointer() || argument_type.is_self_relative_pointer();
        if (needs_to_dereference_pointer) {
          pointer_type := argument_type;
          argument_type = argument_type.base;

          if (pointer_type.is_absolute_pointer()) {
            // We exclude special cases were we do not actually need to load the pointer we got from the expression.
            if (!routine_context.last_resolved_symbol_was_parameter && argument_expression.kind != .Unary) {
              llvm_argument = self.emit_load(routine_context, pointer_type, llvm_argument);
            }
          } else if (pointer_type.is_self_relative_pointer()) {
            llvm_argument = self.emit_self_relative_pointer_to_absolute(routine_context, pointer_type, llvm_argument);
          }
        }

        llvm_argument_type := self.type_to_llvm(argument_type);
        llvm_capacity_pointer: LLVMValueRef;
        if (argument_type.is_dynamic_array_soa_or_aosoa()) {
          base := argument_type.base;
          assert(base.is_struct());
          capacity_index := length((cast(*Type_Struct) base).fields) - 2;
          llvm_capacity_pointer = self.emit_gep_field(self.builder, routine_context, llvm_argument_type, llvm_argument, capacity_index);
        } else {
          llvm_capacity_pointer = self.emit_gep_value_capacity(self.builder, routine_context, llvm_argument_type, llvm_argument);
        }

        if (routine_context.current_loading_mode == .Load_Address) {
          return llvm_capacity_pointer;
        } else {
          return self.emit_load(routine_context, context.storage.type_int, llvm_capacity_pointer);
        }
      }
      case .Hash_Function_Of_Type: {
        hasher_routine_type := cast(*Type_Routine) self.get_resolved_type(expression);
        assert(length(hasher_routine_type.parameters) == 1);
        type := hasher_routine_type.parameters[0].type;

        hasher := self.get_hash_function_for_type(type);
        if (routine_context.current_loading_mode == .Load_Address) {
          return self.emit_temporary_and_store_raw(routine_context, cast(*Type) hasher_routine_type, hasher.llvm_symbol, make_temp_name(routine_context));
        } else {
          return hasher.llvm_symbol;
        }
      }
      case .Compare_Function_Of_Type: {
        comparer_routine_type := cast(*Type_Routine) self.get_resolved_type(expression);
        assert(length(comparer_routine_type.parameters) == 2);
        type := comparer_routine_type.parameters[0].type;

        comparer := self.get_compare_function_for_type(type);
        if (routine_context.current_loading_mode == .Load_Address) {
          return self.emit_temporary_and_store_raw(routine_context, cast(*Type) comparer_routine_type, comparer.llvm_symbol, make_temp_name(routine_context));
        } else {
          return comparer.llvm_symbol;
        } 
      }
      case .Trap: {
        llvm_intrinsic_panic, _ := map_get(&self.llvm_intrinsics, .Trap);
        return LLVMBuildCall2(self.builder, llvm_intrinsic_panic.llvm_type, llvm_intrinsic_panic.llvm_symbol, null, 0, "");
      }
      case .Type_Is_Scalar, .Type_Is_Enum, .Type_Is_Struct, .Type_Is_AoSoA, .Type_Is_Trivial_Copyable: fallthrough;
      case .Type_Enum_Item_Count, .Type_Struct_Field_Count, .Type_AoSoA_Chunk_Size, .Type_AoSoA_Items_In_Chunk: {
        constant, found := self.get_resolved_constant(cast(*Expression) expression);
        assert(found);

        llvm_constant := self.constant_to_llvm(constant.value, constant.type);

        if (routine_context.current_loading_mode == .Load_Address) {
          return self.emit_temporary_and_store_raw(routine_context, constant.type, llvm_constant, make_temp_name(routine_context));
        } else {
          return llvm_constant;
        } 
      }

      case .Invalid: fallthrough;
      case: assert(false);
    }

    assert(false);
    return null;
  }

  /**
  * Emit a call expression to a regular routine.
  * 
  * @param routine_context The context of the routine.
  * @param expression_call The call expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_call_regular(routine_context: *Routine_Context, expression: *Expression_Call) -> LLVMValueRef {
    call_expression := cast(*Expression) expression.expression;
    symbol := self.get_resolved_symbol(call_expression);
    // We skip generating a call for disabled routines.
    if (symbol != null && has_flag(symbol.flags, .Routine_Disabled)) {
      return null;
    }

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
    llvm_call_expression_value := self.emit_expression(routine_context, call_expression, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    routine_type := cast(*Type_Routine) self.get_resolved_type(call_expression);
    llvm_routine_type := self.type_to_llvm_without_routine_promotion(cast(*Type) routine_type);

    llvm_argument_values := array_make!(LLVMValueRef)(0, length(expression.arguments), context.temporary_allocator);

    return_type := self.get_resolved_type(expression);
    // Structs or unions being returned as values are being handled the same as a struct/union argument.
    // We insert the to be returned struct/union as the first argument.
    // Only that we do not need to copy anything as that is what gets returned.
    llvm_return_temporary: LLVMValueRef;
    return_type_is_passed_as_pointer := self.type_is_passed_as_pointer(return_type);
    if (return_type_is_passed_as_pointer) {
      llvm_return_temporary = self.emit_temporary(routine_context, return_type, make_sret_name(routine_context));
      array_add(&llvm_argument_values, llvm_return_temporary);
    }

    // Routines may get the 'context' as their first argument.
    if (routine_type.has_context()) {
      self.emit_expression_call_regular_context_pointer_argument(routine_context, &llvm_argument_values);
    }
    // Methods get a 'self' pointer as their first (or second) argument.
    if (has_flag(routine_type.routine_flags, .Is_Method)) {
      self.emit_expression_call_regular_self_pointer_argument(routine_context, expression, &llvm_argument_values);
    }
    self.emit_expression_call_regular_arguments(routine_context, expression, routine_type, &llvm_argument_values);
    // Emit remaining default parameters that may not have been provided.
    if (length(expression.arguments) < length(routine_type.parameters)) {
      self.emit_expression_call_regular_default_arguments(routine_context, expression, routine_type, &llvm_argument_values);
    }

    name: cstring = "";
    if (!return_type_is_passed_as_pointer && !return_type.is_void()) {
      name = make_value_name(routine_context);
    }
    llvm_return_value := LLVMBuildCall2(
      self.builder,
      llvm_routine_type,
      llvm_call_expression_value,
      data(llvm_argument_values),
      cast(u32) length(llvm_argument_values),
      name,
    );

    routine_context.last_resolved_symbol_was_parameter = false;

    if (return_type_is_passed_as_pointer) {
      // For things that are being passed as pointers we have to load them from the out-parameter pointer as a final step.
      if (routine_context.current_loading_mode == .Load_Address) {
        return llvm_return_temporary;
      } else {
        return self.emit_load(routine_context, return_type, llvm_return_temporary);
      }
    } else {
      if (routine_context.current_loading_mode == .Load_Address) {
        return self.emit_temporary_and_store_raw(routine_context, routine_type.return_type, llvm_return_value, make_temp_name(routine_context));
      } else {
        return llvm_return_value;
      }
    }
  }

  /**
  * Emit the context pointer argument for a regular call expression.
  * 
  * @param routine_context      The context of the routine.
  * @param llvm_argument_values The LLVM arguments to fill.
  */
  private proc emit_expression_call_regular_context_pointer_argument(routine_context: *Routine_Context, llvm_argument_values: *[dynamic]LLVMValueRef) {
    local_symbol, found := self.get_local_symbol(routine_context, SPECIAL_NAME_CONTEXT);
    assert(found);

    if (local_symbol.is_parameter) {
      // Parameters can simply be passed along.
      array_add(llvm_argument_values, local_symbol.llvm_value);
    } else {
      // Actual locals have to be loaded as a pointer first. This is the case when the 'push_context' statement got used.
      llvm_context_pointer := self.emit_load(routine_context, context.storage.type_rawptr, local_symbol.llvm_value);
      array_add(llvm_argument_values, llvm_context_pointer);
    }
  }

  /**
  * Emit the self-pointer argument for a regular call expression.
  * 
  * @param routine_context      The context of the routine.
  * @param expression_call      The call expression to emit.
  * @param llvm_argument_values The LLVM arguments to fill.
  */
  private proc emit_expression_call_regular_self_pointer_argument(
    routine_context: *Routine_Context,
    expression: *Expression_Call,
    llvm_argument_values: *[dynamic]LLVMValueRef,
  ) {
    call_expression := cast(*Expression) expression.expression;
    // If we have a method we know that previous expression must be a field expression.
    assert(call_expression.kind == .Member);

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
    self_expression := cast(*Expression) (cast(*Expression_Member) call_expression).expression;
    llvm_self := self.emit_expression(routine_context, self_expression, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);
    
    self_type := self.get_resolved_type(self_expression);

    if (LLVMIsConstant(llvm_self)) {
      llvm_temp := self.emit_temporary(routine_context, self_type, make_temp_name(routine_context));
      self.emit_store_raw(llvm_temp, llvm_self);
      llvm_self = llvm_temp;
    } else if (self_type.is_dynamic_pointer()) {
      llvm_type := self.type_to_llvm(self_type);
      llvm_dynamic_pointer_data_pointer := self.emit_gep_value_data(self.builder, routine_context, llvm_type, llvm_self);
      llvm_dynamic_pointer_data := self.emit_load(routine_context, context.storage.type_rawptr, llvm_dynamic_pointer_data_pointer);
      llvm_self = llvm_dynamic_pointer_data;
    } else if (!self_type.is_absolute_or_relative_pointer_like() && !self.type_is_passed_as_pointer(self_type) && routine_context.last_resolved_symbol_was_parameter) {
      // When we do not directly have a pointer at our hands we need to handle that.
      // This occurs when basic types are passed and directly used. For example: proc example(i: int) { i.foo(); }.
      // In this scenario we need to create a new proper storage location for the parameter.
      // But it has to be correctly inserted into the scope, so that modifications are propagated properly.
      name := routine_context.last_resolved_symbol_name;

      llvm_type := self.type_to_llvm(self_type);
      previous_block := self.enter_llvm_block(routine_context, routine_context.declaration_block);
      llvm_parameter_overwrite := LLVMBuildAlloca(self.builder, llvm_type, make_variable_name(routine_context, name));
      self.enter_llvm_block(routine_context, previous_block);

      scope := routine_context.local_scope;
      for (scope.parent != null) {
        scope = scope.parent;
      }
      self.add_local_symbol(name, llvm_parameter_overwrite, llvm_type, self_type, false, scope);

      self.emit_store_raw(llvm_parameter_overwrite, llvm_self);
      llvm_self = llvm_parameter_overwrite;
    } else if (self_type.is_absolute_pointer() && !routine_context.last_resolved_symbol_was_parameter) {
      llvm_self = self.emit_load(routine_context, context.storage.type_rawptr, llvm_self);
    } else if (self_type.is_relative_pointer()) {
      llvm_self = self.emit_self_relative_pointer_to_absolute(routine_context, self_type, llvm_self);
      llvm_self = self.emit_load(routine_context, context.storage.type_rawptr, llvm_self);
    } 

    array_add(llvm_argument_values, llvm_self);
  }

  /**
  * Emit the arguments for a regular call expression.
  * 
  * @param routine_context      The context of the routine.
  * @param expression_call      The call expression to emit.
  * @param type_routine         The type of the routine.
  * @param llvm_argument_values The LLVM arguments to fill.
  */
  private proc emit_expression_call_regular_arguments(
    routine_context: *Routine_Context,
    expression: *Expression_Call,
    routine_type: *Type_Routine,
    llvm_argument_values: *[dynamic]LLVMValueRef,
  ) {
    has_params := has_flag(routine_type.routine_flags, .Has_Params);
    parameter_count := length(routine_type.parameters);

    // There are 3 scenarios for params arguments:
    //   1. We get no additional arguments for the params.
    //      That means we have to create an empty slice that gets passed instead.
    //   2. We get one argument whose slice type is equal to the type of the params slice parameter type.
    //      Here we can just pass along that slice as a regular argument.
    //   3. We get one or more argument where the types do not correspond to the slice parameter type.
    //      This is where we fill an array with all the arguments provided.
    //      This array is the data source for the slice that gets actually passed
    //      and whose length corresponds to the number of params arguments provided.
    params_kind := Params_Kind.None;
    params_type: *Type;
    llvm_params_slice: LLVMValueRef;
    llvm_params_slice_array: LLVMValueRef;
    llvm_params_slice_array_type: LLVMTypeRef;

    if (has_params) {
      params_type = routine_type.parameters[parameter_count - 1].type;
      params_arguments_count := length(expression.arguments) - parameter_count + 1;

      if (params_arguments_count <= 0) {
        params_kind = .Empty;
      } else if (params_arguments_count == 1) {
        params_argument_type := self.get_resolved_overwrite_type(expression.arguments[length(expression.arguments) - 1]);
        params_kind = params_argument_type == params_type ? .Pass : .Fill;
      } else if (params_arguments_count > 1) {
        params_kind = .Fill;
      }

      if (params_kind == .Empty || params_kind == .Fill) {
        llvm_params_slice = self.emit_temporary(routine_context, params_type, make_slice_name(routine_context));
        llvm_params_slice_type := self.type_to_llvm(params_type);

        if (params_kind == .Empty) {
          self.emit_store_raw(llvm_params_slice, LLVMConstNull(llvm_params_slice_type));
        } else {
          params_array_type := context.storage.get_or_make_type_array(SOA_INFO_NONE, params_type.base, params_arguments_count, false);
          llvm_params_slice_array = self.emit_temporary(routine_context, params_array_type, make_array_name(routine_context));
          llvm_params_slice_array_type = self.type_to_llvm(params_array_type);

          llvm_params_slice_data_pointer := self.emit_gep_value_data(self.builder, routine_context, llvm_params_slice_type, llvm_params_slice);
          self.emit_store_raw(llvm_params_slice_data_pointer, llvm_params_slice_array);
          llvm_params_slice_length_pointer := self.emit_gep_value_length(self.builder, routine_context, llvm_params_slice_type, llvm_params_slice);
          self.emit_store_raw(llvm_params_slice_length_pointer, LLVMConstInt(LLVMInt64Type(), cast(u64) params_arguments_count, false));
        }
      }
    }

    foreach (argument_expression, i in expression.arguments) {
      argument_type: *Type = null;
      // We can look up the argument type as long as we have enough non c-varargs arguments.
      is_params_argument := false;
      if (i < parameter_count) {
        parameter := routine_type.parameters[i];
        argument_type = parameter.type;
        
        // Special case for the first params argument.
        if (params_kind == .Fill && i == parameter_count - 1) {
          is_params_argument = true;
          argument_type = params_type.base;
        }
      } else if (has_params) {
        is_params_argument = true;
        argument_type = params_type.base;
      }

      overwrite_argument_type := self.get_resolved_overwrite_type(argument_expression);
      needs_to_load_address := argument_type == null ? false : self.type_requires_loading_address(argument_type, overwrite_argument_type);
      previous_loading_mode := self.enter_loading_mode(routine_context, needs_to_load_address ? .Load_Address : .Load_Value);
      llvm_argument_value := self.emit_expression(routine_context, argument_expression, overwrite_argument_type);
      self.leave_loading_mode(routine_context, previous_loading_mode);

      if (is_params_argument && params_kind == .Fill) {
        params_index := i - parameter_count + 1;
        llvm_params_array_element_pointer := self.emit_gep_field(self.builder, routine_context, llvm_params_slice_array_type, llvm_params_slice_array, params_index);
        self.emit_store(routine_context, argument_type, llvm_params_array_element_pointer, llvm_argument_value, argument_expression);
      } else {
        // If we pass a struct or union by value we actually pass it in as a pointer. So what we do is the following:
        //   1. Request the regual referenced struct/union.
        //   2. Copy it to a temporary local.
        //   3. Pass in the pointer to that temporary local as the actual argument.
        // This is currently probably undefined for c-varargs.      
        if (argument_type != null && self.type_is_passed_as_pointer(argument_type)) {
          llvm_temporary := self.emit_temporary(routine_context, argument_type, make_byval_name(routine_context));
          routine_context.is_storing_byval_or_sret = true;
          self.emit_store(routine_context, argument_type, llvm_temporary, llvm_argument_value, argument_expression);
          routine_context.is_storing_byval_or_sret = false;
          llvm_argument_value = llvm_temporary;
        }
        array_add(llvm_argument_values, llvm_argument_value);
      }
    }

    if (params_kind == .Empty || params_kind == .Fill) {
      array_add(llvm_argument_values, llvm_params_slice);
    }
  }

  /**
  * Emit the default arguments for a regular call expression.
  * 
  * @param routine_context      The context of the routine.
  * @param expression_call      The call expression to emit.
  * @param type_routine         The type of the routine.
  * @param llvm_argument_values The LLVM arguments to fill.
  */
  private proc emit_expression_call_regular_default_arguments(
    routine_context: *Routine_Context,
    expression: *Expression_Call,
    routine_type: *Type_Routine,
    llvm_argument_values: *[dynamic]LLVMValueRef,
  ) {
    symbol := self.get_resolved_symbol(cast(*Expression) expression.expression);
    if (symbol != null) {
      declaration := cast(*Declaration_Routine) symbol.declaration;
      
      default_parameter_count_end := length(routine_type.parameters);
      if (has_flag(routine_type.routine_flags, .Has_Params)) {
        default_parameter_count_end -= 1;
      }

      for (i := length(expression.arguments); i < default_parameter_count_end; i += 1) {
        parameter := routine_type.parameters[i];
        assert(parameter.is_default);
        declaration_parameter := declaration.parameters[i];

        llvm_initializer_value: LLVMValueRef;
        default_initializer := declaration_parameter.initializer;
        initializer_constant, found_constant := self.get_resolved_constant(default_initializer);
        if (default_initializer.kind == .Directive) {
          // We handle directives explicitly, so that the correct source location is being used.
          directive_kind := (cast(*Expression_Directive) default_initializer).directive_kind;
          assert(directive_kind == .Line || directive_kind == .Routine || directive_kind == .File || directive_kind == .Location);
          llvm_initializer_value = self.emit_expression_directive_constant(routine_context, directive_kind, expression.position);
        } else if (found_constant) {
          llvm_initializer_value = self.constant_to_llvm(initializer_constant.value, parameter.type);
        } else {
          previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
          llvm_initializer_value = self.emit_expression(routine_context, default_initializer, parameter.type);
          self.leave_loading_mode(routine_context, previous_loading_mode);
        }

        if (self.type_is_passed_as_pointer(parameter.type)) {
          llvm_temporary := self.emit_temporary(routine_context, parameter.type, make_byval_name(routine_context));
          self.emit_store(routine_context, parameter.type, llvm_temporary, llvm_initializer_value, default_initializer);
          llvm_initializer_value = llvm_temporary;
        }

        array_add(llvm_argument_values, llvm_initializer_value);
      }
    }
  }
  
  /**
  * Emit an index expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_index(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    expression := cast(*Expression_Index) expression;
    index_expression := cast(*Expression) expression.expression;

    value_to_index_type := self.get_resolved_type(index_expression);
    index_type := self.get_resolved_type(cast(*Expression) expression.index);
    is_using_offset_relative_pointer := index_type.is_offset_relative_pointer();

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
    llvm_index := self.emit_expression(routine_context, cast(*Expression) expression.index, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    needs_to_load_address := !is_using_offset_relative_pointer || value_to_index_type.is_self_relative_pointer();
    previous_loading_mode = self.enter_loading_mode(routine_context, needs_to_load_address ? .Load_Address : .Load_Value);
    llvm_value_to_index := self.emit_expression(routine_context, index_expression, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    needs_to_dereference_pointer := value_to_index_type.is_absolute_pointer() || value_to_index_type.is_self_relative_pointer(); 
    possible_collection_type := value_to_index_type;
    if (needs_to_dereference_pointer) {
      possible_collection_type = possible_collection_type.base;
    }
    if (possible_collection_type.is_soa_or_aosoa()) {
      llvm_layout_collection := self.emit_possible_pointer_dereference(routine_context, index_expression, llvm_value_to_index);
      return self.emit_layout_index_access(routine_context, possible_collection_type, llvm_layout_collection, llvm_index);
    }

    llvm_pointer: LLVMValueRef;
    if (is_using_offset_relative_pointer) {
      if (value_to_index_type.is_self_relative_pointer()) {
        llvm_value_to_index = self.emit_self_relative_pointer_to_absolute(routine_context, value_to_index_type, llvm_value_to_index);
      }

      // When dealing with indexing pointers through offset-relative pointer we have to calculate the proper offset based on the pointers base type.
      llvm_pointer = self.emit_gep_pointer(self.builder, routine_context, self.type_to_llvm(index_type.base), llvm_value_to_index, llvm_index);
    } else {
      if (needs_to_dereference_pointer) {
        value_to_index_type = value_to_index_type.base;
      }
      llvm_value_to_index = self.emit_possible_pointer_dereference(routine_context, index_expression, llvm_value_to_index);
      llvm_value_to_index_type := self.type_to_llvm(value_to_index_type);

      if (value_to_index_type.is_array()) {
        llvm_pointer = self.emit_gep_field_dynamic(self.builder, routine_context, llvm_value_to_index_type, llvm_value_to_index, llvm_index);
      } else {
        // For dynamic arrays and slices we are basically doing pointer arithmetic with the corresponding 'data' pointer.
        llvm_value_to_index = self.emit_gep_value_data(self.builder, routine_context, llvm_value_to_index_type, llvm_value_to_index);
        slice_data_pointer_type := context.storage.get_or_make_type_pointer(value_to_index_type.base);
        llvm_value_to_index_type = self.type_to_llvm(value_to_index_type.base);
        llvm_value_to_index = self.emit_load(routine_context, slice_data_pointer_type, llvm_value_to_index);
        llvm_pointer = self.emit_gep_pointer(self.builder, routine_context, llvm_value_to_index_type, llvm_value_to_index, llvm_index);
      }
    }

    // Either we load the element at the index or return the pointer to it.
    if (routine_context.current_loading_mode == .Load_Address) {
      return llvm_pointer;
    } else {
      element_type := self.get_resolved_type(expression);
      return self.emit_load(routine_context, element_type, llvm_pointer);
    }
  }

  /**
  * Emit a slice expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_slice(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    expression := cast(*Expression_Slice) expression;
    slice_epxression := cast(*Expression) expression.expression;

    slice_expression_type := self.get_resolved_type(slice_epxression);
    needs_to_dereference_pointer := slice_expression_type.is_absolute_pointer() || slice_expression_type.is_self_relative_pointer();
    value_to_slice_type := slice_expression_type;
    if (needs_to_dereference_pointer) {
      value_to_slice_type = slice_expression_type.base;
    }

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
    llvm_value_to_slice_pointer := self.emit_expression(routine_context, slice_epxression, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);
    llvm_value_to_slice_pointer = self.emit_possible_pointer_dereference(routine_context, slice_epxression, llvm_value_to_slice_pointer);

    llvm_value_to_slice_type := self.type_to_llvm(value_to_slice_type);
    produces_soa_slice := value_to_slice_type.is_soa();

    llvm_value_to_slice_length: LLVMValueRef;
    llvm_value_to_slice_data_pointer: LLVMValueRef;
    if (value_to_slice_type.is_array()) {
      // We might still end up here if we are producing an SoA slice from a fixed array but that is intentional.
      type_array := cast(*Type_Array) value_to_slice_type;
      number_of_elements := cast(u64) type_array.number_of_elements;
      llvm_value_to_slice_length = LLVMConstInt(LLVMInt64Type(), number_of_elements, false);
      llvm_value_to_slice_data_pointer = llvm_value_to_slice_pointer;
    } else if (produces_soa_slice) {
      // This handles getting the variable length from SoA types (meaning dynamic arrays and slices).
      field_offset_from_end := value_to_slice_type.is_slice() ? 1 : 3;
      length_index := length((cast(*Type_Struct) value_to_slice_type.base).fields) - field_offset_from_end;
      llvm_value_to_slice_length_pointer := self.emit_gep_field(self.builder, routine_context, llvm_value_to_slice_type, llvm_value_to_slice_pointer, length_index);
      llvm_value_to_slice_length = self.emit_load(routine_context, context.storage.type_int, llvm_value_to_slice_length_pointer);
    } else {
      llvm_value_to_slice_data_pointer_pointer := self.emit_gep_value_data(self.builder, routine_context, llvm_value_to_slice_type, llvm_value_to_slice_pointer);
      llvm_value_to_slice_data_pointer = self.emit_load(routine_context, context.storage.type_rawptr, llvm_value_to_slice_data_pointer_pointer);
      llvm_value_to_slice_length_pointer := self.emit_gep_value_length(self.builder, routine_context, llvm_value_to_slice_type, llvm_value_to_slice_pointer);
      llvm_value_to_slice_length = self.emit_load(routine_context, context.storage.type_int, llvm_value_to_slice_length_pointer);
    }

    slice_result_type := self.get_resolved_type(expression);
    llvm_slice_result_type := self.type_to_llvm(slice_result_type);
    llvm_slice_result := self.emit_temporary(routine_context, slice_result_type, make_slice_name(routine_context));

    llvm_lower_bound: LLVMValueRef;
    if (expression.lower == null) {
      llvm_lower_bound = LLVMConstInt(LLVMInt64Type(), 0, false);
    } else {
      previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
      llvm_lower_bound = self.emit_expression(routine_context, cast(*Expression) expression.lower, null);
      self.leave_loading_mode(routine_context, previous_loading_mode);
    }

    llvm_higher_bound: LLVMValueRef;
    if (expression.higher == null) {
      llvm_higher_bound = llvm_value_to_slice_length;
    } else {
      previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
      llvm_higher_bound = self.emit_expression(routine_context, cast(*Expression) expression.higher, null);
      self.leave_loading_mode(routine_context, previous_loading_mode);
    }

    if (produces_soa_slice) {
      // For an soa slice we have to deal with multiple data pointers for each field and not just a single one.

      // We iterate over the fields of the 'regular' struct (the base of the layout struct base).
      fields := (cast(*Type_Struct) slice_result_type.base.base).fields;
      foreach (field, i in fields) {
        llvm_value_field_pointer := self.emit_gep_field(self.builder, routine_context, llvm_value_to_slice_type, llvm_value_to_slice_pointer, i);
        llvm_field_type := self.type_to_llvm(field.type);
        llvm_value_field_data_pointer := self.emit_gep_pointer(self.builder, routine_context, llvm_field_type, llvm_value_field_pointer, llvm_lower_bound);
        llvm_slice_result_field_pointer := self.emit_gep_field(self.builder, routine_context, llvm_slice_result_type, llvm_slice_result, i);
        self.emit_store_raw(llvm_slice_result_field_pointer, llvm_value_field_data_pointer);
      }
    } else {
      // We calculate the data pointer offset based on the lower bound.
      llvm_result_element_type := value_to_slice_type.is_string() ? self.type_to_llvm(context.storage.type_u8) : self.type_to_llvm(slice_result_type.base);
      llvm_result_data := self.emit_gep_pointer(self.builder, routine_context, llvm_result_element_type, llvm_value_to_slice_data_pointer, llvm_lower_bound);
      llvm_slice_data_pointer := self.emit_gep_value_data(self.builder, routine_context, llvm_slice_result_type, llvm_slice_result);
      self.emit_store_raw(llvm_slice_data_pointer, llvm_result_data);
    }

    // We calculate the slice length based on the difference between the higher and lower bound.
    llvm_slice_length := LLVMBuildSub(self.builder, llvm_higher_bound, llvm_lower_bound, make_value_name(routine_context));
    llvm_slice_length_pointer: LLVMValueRef;
    if (produces_soa_slice) {
      field_offset_from_end := 1;
      length_index := length((cast(*Type_Struct) slice_result_type.base).fields) - field_offset_from_end;
      llvm_slice_length_pointer = self.emit_gep_field(self.builder, routine_context, llvm_slice_result_type, llvm_slice_result, length_index);
    } else {
      llvm_slice_length_pointer = self.emit_gep_value_length(self.builder, routine_context, llvm_slice_result_type, llvm_slice_result);
    }
    self.emit_store_raw(llvm_slice_length_pointer, llvm_slice_length);

    if (routine_context.current_loading_mode == .Load_Address) {
      return llvm_slice_result;
    } else {
      return self.emit_load(routine_context, slice_result_type, llvm_slice_result);
    }
  }
  
  /**
  * Emit a member expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_member(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    expression := cast(*Expression_Member) expression;

    value_type := self.get_resolved_type(expression);

    // First check if we referenced a symbol which we can just return directly (this is the case for packages or methods).
    symbol := self.get_resolved_symbol(cast(*Expression) expression);
    if (symbol != null) {
      return self.emit_expression_name_load_symbol(routine_context, symbol, value_type, self.symbol_to_llvm(symbol));
    }

    member_expression := cast(*Expression) expression.expression;

    member_expression_type := self.get_resolved_type(member_expression);
    if (self.member_is_soa_or_aosoa_access(member_expression)) {
      return self.emit_expression_member_layout(routine_context, expression, value_type);
    }

    needs_to_dereference_pointer := member_expression_type.is_absolute_pointer() || member_expression_type.is_self_relative_pointer();

    // This is necessary so that chained expressions like 'foo.bar.baz' get correctly generated when 'foo' is a parameter.
    defer routine_context.last_resolved_symbol_was_parameter = false;

    if (member_expression_type.is_enumeration()) {
      // Here we know that we are referring to a enum item constant.
      resolved_constant, _ := self.get_resolved_constant(cast(*Expression) expression);
      return self.constant_to_llvm(resolved_constant.value, value_type);
    } else if (member_expression_type.is_struct() || needs_to_dereference_pointer) {
      struct_type := member_expression_type;
      if (needs_to_dereference_pointer) {
        struct_type = member_expression_type.base;
      }

      resolved_member := self.get_resolved_member(cast(*Expression) expression);

      previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
      llvm_struct_pointer := self.emit_expression(routine_context, member_expression, null);
      self.leave_loading_mode(routine_context, previous_loading_mode);
      llvm_struct_pointer = self.emit_possible_pointer_dereference(routine_context, member_expression, llvm_struct_pointer);

      llvm_struct_type := self.type_to_llvm(struct_type);
      llvm_field_pointer := self.emit_gep_member(self.builder, routine_context, llvm_struct_type, llvm_struct_pointer, resolved_member);

      if (routine_context.current_loading_mode == .Load_Address) {
        return llvm_field_pointer;
      } else {
        return self.emit_load(routine_context, value_type, llvm_field_pointer);
      }
    } else if (member_expression_type.is_layout_pointer()) {
      previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
      llvm_layout_pointer := self.emit_expression(routine_context, member_expression, null);
      self.leave_loading_mode(routine_context, previous_loading_mode);

      layout_collection_type := member_expression_type.base;

      llvm_layout_pointer_type := self.type_to_llvm(member_expression_type);
      llvm_layout_pointer_data_pointer := self.emit_gep_value_data(self.builder, routine_context, llvm_layout_pointer_type, llvm_layout_pointer);
      llvm_layout_pointer_data := self.emit_load(routine_context, context.storage.type_rawptr, llvm_layout_pointer_data_pointer);
      llvm_layout_pointer_index_pointer := self.emit_gep_value_length(self.builder, routine_context, llvm_layout_pointer_type, llvm_layout_pointer);
      llvm_layout_pointer_index := self.emit_load(routine_context, context.storage.type_int, llvm_layout_pointer_index_pointer);

      resolved_member := self.get_resolved_member(cast(*Expression) expression);
      return self.emit_layout_member_access(
        routine_context,
        layout_collection_type,
        resolved_member,
        value_type,
        llvm_layout_pointer_data,
        llvm_layout_pointer_index,
      );
    } else if (member_expression_type.is_dynamic_pointer()) {
      previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
      llvm_dynamic_pointer_pointer := self.emit_expression(routine_context, member_expression, null);
      self.leave_loading_mode(routine_context, previous_loading_mode);

      llvm_dynamic_pointer_type := self.type_to_llvm(member_expression_type);
      llvm_dynamic_pointer_vtable_pointer_pointer := self.emit_gep_value_length(self.builder, routine_context, llvm_dynamic_pointer_type, llvm_dynamic_pointer_pointer);
      llvm_dynamic_pointer_vtable_pointer := self.emit_load(routine_context, context.storage.type_rawptr, llvm_dynamic_pointer_vtable_pointer_pointer);

      resolved_member := self.get_resolved_member(cast(*Expression) expression);
      
      llvm_vtable_type := self.type_to_llvm(member_expression_type.base);
      llvm_function_pointer_pointer := self.emit_gep_member(self.builder, routine_context, llvm_vtable_type, llvm_dynamic_pointer_vtable_pointer, resolved_member);

      if (routine_context.current_loading_mode == .Load_Address) {
        return llvm_function_pointer_pointer;
      } else {
        return self.emit_load(routine_context, value_type, llvm_function_pointer_pointer);
      }
    }

    assert(false);
    return null;
  }

  /**
  * Emit a member expression for a layout collection.
  * 
  * @param routine_context   The context of the routine.
  * @param expression_member The expression to emit.
  * @param value_type        The type of the member that gets accessed.
  * @return The value of the expression.
  */
  private proc emit_expression_member_layout(routine_context: *Routine_Context, expression: *Expression_Member, value_type: *Type) -> LLVMValueRef {
    // Here we have two implicit SoA/AoSoA scenarios we handle (not related to SoA/AoSoA pointers):
    //   1. Accessing the field of an element -> Just access the single array/data of the appropriate field.
    //   2. Getting the address of a field of an element -> Here we can just access the single array/data buffer to get appropriate the pointer.
    member_expression := cast(*Expression) expression.expression;

    assert(member_expression.kind == .Index);
    expression_index := cast(*Expression_Index) member_expression;
    index_expression := cast(*Expression) expression_index.expression;

    layout_collection_type := self.get_resolved_type(index_expression);
    needs_to_dereference_pointer := layout_collection_type.is_absolute_pointer() || layout_collection_type.is_self_relative_pointer();
    if (needs_to_dereference_pointer) {
      layout_collection_type = layout_collection_type.base;
    }
    
    // We directly get the pointer for the array from the INDEX expression (and skip the regular emission of the index expression).
    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
    llvm_layout_collection_pointer := self.emit_expression(routine_context, index_expression, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);
    llvm_layout_collection_pointer = self.emit_possible_pointer_dereference(routine_context, index_expression, llvm_layout_collection_pointer);
    
    previous_loading_mode = self.enter_loading_mode(routine_context, .Load_Value);
    llvm_index := self.emit_expression(routine_context, cast(*Expression) expression_index.index, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);
    
    resolved_member := self.get_resolved_member(cast(*Expression) expression);
    return self.emit_layout_member_access(routine_context, layout_collection_type, resolved_member, value_type, llvm_layout_collection_pointer, llvm_index);
  }

  /**
  * Emit a compound expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_compound(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    expression := cast(*Expression_Compound) expression;
    compound_type := self.get_resolved_type(expression);

    is_empty := length(expression.fields) == 0;
    if (is_empty) {
      llvm_initializer_value := self.default_initializer_value(compound_type);
      if (routine_context.current_loading_mode == .Load_Address) {
        return self.emit_temporary_and_store_raw(routine_context, compound_type, llvm_initializer_value, make_compound_name(routine_context));
      } else {
        return llvm_initializer_value;
      }
    }

    is_slice := compound_type.is_slice();
    slice_type: *Type;
    if (is_slice) {
      slice_type = compound_type;
      compound_type = context.storage.get_or_make_type_array(SOA_INFO_NONE, compound_type.base, length(expression.fields), false);
    }

    llvm_compound: LLVMValueRef;
    if (is_slice && routine_context.is_global_initializer) {
      // The backing array for slices has to be created globally.
      llvm_compound = self.emit_temporary_global(compound_type);
    } else {
      llvm_compound = self.emit_temporary(routine_context, compound_type, make_compound_name(routine_context));
    }
    llvm_compound_type := self.type_to_llvm(compound_type);

    foreach (field in expression.fields) {
      field_initializer := field.initializer;

      compound_field_index := self.get_resolved_compound_field(field_initializer);
      compound_field_type := compound_field_index.type;
      
      overwrite_type := self.get_resolved_overwrite_type(field_initializer);
      needs_to_load_address := self.type_requires_loading_address(compound_field_type, overwrite_type);
      previous_loading_mode := self.enter_loading_mode(routine_context, needs_to_load_address ? .Load_Address : .Load_Value);
      llvm_field_value := self.emit_expression(routine_context, field_initializer, overwrite_type);
      self.leave_loading_mode(routine_context, previous_loading_mode);

      llvm_field_pointer := self.emit_gep_field(self.builder, routine_context, llvm_compound_type, llvm_compound, compound_field_index.index);
      self.emit_store(routine_context, compound_field_type, llvm_field_pointer, llvm_field_value, field_initializer);
    }

    if (is_slice) {
      return self.emit_expression_compound_slice(routine_context, slice_type, length(expression.fields), llvm_compound);
    } else {
      if (routine_context.current_loading_mode == .Load_Value) {
        return self.emit_load(routine_context, compound_type, llvm_compound);
      } else {
        return llvm_compound;
      }
    }
  }

  /**
  * Emit a compound expression for a slice.
  * 
  * @param routine_context    The context of the routine.
  * @param slice_type         The type of the slice.
  * @param element_count      The count of the elements in the slice.
  * @param llvm_array_pointer The LLVM pointer to the array the slice will reference.
  * @return The value of the expression.
  */
  private proc emit_expression_compound_slice(
    routine_context: *Routine_Context,
    slice_type: *Type,
    element_count: int,
    llvm_array_pointer: LLVMValueRef,
  ) -> LLVMValueRef {
    assert(slice_type.is_slice());

    llvm_slice_type := self.type_to_llvm(slice_type);
    llvm_slice := self.emit_temporary(routine_context, slice_type, make_slice_name(routine_context));

    // First set the data pointer of the slice.
    llvm_slice_data_pointer := self.emit_gep_value_data(self.builder, routine_context, llvm_slice_type, llvm_slice);
    self.emit_store_raw(llvm_slice_data_pointer, llvm_array_pointer);

    // Now set the length of the slice.
    llvm_slice_length_pointer := self.emit_gep_value_length(self.builder, routine_context, llvm_slice_type, llvm_slice);
    llvm_slice_length_value := LLVMConstInt(LLVMInt64Type(), cast(u64) element_count, false);
    self.emit_store_raw(llvm_slice_length_pointer, llvm_slice_length_value);

    if (routine_context.current_loading_mode == .Load_Address) {
      return llvm_slice;
    } else {
      return self.emit_load(routine_context, slice_type, llvm_slice);
    }
  }

  /**
  * Emit a selector expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_selector(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    expression := cast(*Expression_Selector) expression;
    selector_expression := cast(*Expression) expression.expression;

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
    llvm_union := self.emit_expression(routine_context, selector_expression, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);
    llvm_union = self.emit_possible_pointer_dereference(routine_context, selector_expression, llvm_union);

    union_type := self.get_resolved_type(selector_expression);
    if (union_type.is_absolute_pointer() || union_type.is_self_relative_pointer()) {
      union_type = union_type.base;
    }
    llvm_union_type := self.type_to_llvm(union_type);
    llvm_union_data_pointer := self.emit_gep_union_value(self.builder, routine_context, llvm_union_type, llvm_union);

    routine_context.last_resolved_symbol_was_parameter = false;

    if (routine_context.current_loading_mode == .Load_Address) {
      return llvm_union_data_pointer;
    } else {
      selected_type := self.get_resolved_type(cast(*Type_Specification) expression.type);
      return self.emit_load(routine_context, selected_type, llvm_union_data_pointer);
    }
  }

  /**
  * Emit an implicit selector expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @param type            The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_implicit_selector(expression: *Expression, type: *Type) -> LLVMValueRef {
    resolved_constant, found := self.get_resolved_constant(expression);
    assert(found);
    return self.constant_to_llvm(resolved_constant.value, type);
  }

  /**
  * Emit a unary expression.
  * 
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @param type            The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_unary(routine_context: *Routine_Context, expression: *Expression, type: *Type) -> LLVMValueRef {
    expression := cast(*Expression_Unary) expression;
    operator := expression.operator;

    if (operator == .And || operator == .Multiply) {
      return self.emit_expression_unary_memory(routine_context, expression, type);
    } else {
      return self.emit_expression_unary_regular(routine_context, expression, type);
    }
  }

  /**
  * Emit a memory unary expression.
  * 
  * @param routine_context  The context of the routine.
  * @param expression_unary The expression to emit.
  * @param type             The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_unary_memory(routine_context: *Routine_Context, expression: *Expression_Unary, type: *Type) -> LLVMValueRef {
    operator := expression.operator;
    unary_expression := cast(*Expression) expression.expression;

    resolved_expression_type := self.get_resolved_type(unary_expression);
    is_dereferencing_layout_pointer := resolved_expression_type.is_layout_pointer() && operator == .Multiply;
    if (type.is_layout_pointer() || is_dereferencing_layout_pointer) {
      return self.emit_expression_unary_memory_layout(routine_context, expression, is_dereferencing_layout_pointer ? resolved_expression_type : type);
    }

    is_self_relative_pointer := resolved_expression_type.is_self_relative_pointer();
    needs_to_load_address := operator == .And || is_self_relative_pointer;
    previous_loading_mode := self.enter_loading_mode(routine_context, needs_to_load_address ? .Load_Address : .Load_Value);
    // We explicitly do not request the provided type when dealing with pointers (as they are specially handled).
    expression_type: *Type = operator == .And || operator == .Multiply ? null : type;
    llvm_expression_value := self.emit_expression(routine_context, unary_expression, expression_type);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    // First we handle the reading and writing of pointers.
    if (operator == .Multiply) {
      llvm_pointer_to_load := llvm_expression_value;

      if (is_self_relative_pointer) {
        llvm_pointer_to_load = self.emit_self_relative_pointer_to_absolute(routine_context, resolved_expression_type, llvm_expression_value);
      }

      if (routine_context.current_loading_mode == .Load_Address) {
        return llvm_pointer_to_load;
      } else {
        return self.emit_load(routine_context, type, llvm_pointer_to_load);
      }
    } else {
      assert(operator == .And);

      // We should just be able to return the value, as it should already be a pointer.
      return llvm_expression_value;
    }
  }

  /**
  * Emit a memory unary expression with layout pointers.
  * 
  * @param routine_context     The context of the routine.
  * @param expression_unary    The expression to emit.
  * @param layout_pointer_type The type of the layout_pointer.
  * @return The value of the expression.
  */
  private proc emit_expression_unary_memory_layout(
    routine_context: *Routine_Context,
    expression: *Expression_Unary,
    layout_pointer_type: *Type,
  ) -> LLVMValueRef {
    operator := expression.operator;
    llvm_layout_pointer_type := self.type_to_llvm(layout_pointer_type);

    if (operator == .Multiply) {
      previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
      llvm_layout_pointer := self.emit_expression(routine_context, cast(*Expression) expression.expression, null);
      self.leave_loading_mode(routine_context, previous_loading_mode);

      llvm_layout_pointer_data_pointer := self.emit_gep_value_data(self.builder, routine_context, llvm_layout_pointer_type, llvm_layout_pointer);
      llvm_layout_pointer_data := self.emit_load(routine_context, context.storage.type_rawptr, llvm_layout_pointer_data_pointer);
      llvm_layout_pointer_index_pointer := self.emit_gep_value_length(self.builder, routine_context, llvm_layout_pointer_type, llvm_layout_pointer);
      llvm_layout_pointer_index := self.emit_load(routine_context, context.storage.type_int, llvm_layout_pointer_index_pointer);
      return self.emit_layout_index_access(routine_context, layout_pointer_type.base, llvm_layout_pointer_data, llvm_layout_pointer_index);
    } else {
      assert(operator == .And);

      assert(expression.expression.kind == .Index);
      expression_index := cast(*Expression_Index) expression.expression;
      index_expression := cast(*Expression) expression_index.expression;

      previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
      llvm_index := self.emit_expression(routine_context, cast(*Expression) expression_index.index, null);
      self.leave_loading_mode(routine_context, previous_loading_mode);

      value_to_index_type := self.get_resolved_type(index_expression);
      previous_loading_mode = self.enter_loading_mode(routine_context, .Load_Address);
      llvm_value_to_index := self.emit_expression(routine_context, index_expression, null);
      self.leave_loading_mode(routine_context, previous_loading_mode);
      needs_to_dereference_pointer := value_to_index_type.is_absolute_pointer() || value_to_index_type.is_self_relative_pointer();
      if (needs_to_dereference_pointer) {
        llvm_value_to_index = self.emit_possible_pointer_dereference(routine_context, index_expression, llvm_value_to_index);
        value_to_index_type = value_to_index_type.base;
      }
      llvm_value_to_index_type := self.type_to_llvm(value_to_index_type);
      llvm_value_to_index_data := self.emit_gep_value_data(self.builder, routine_context, llvm_value_to_index_type, llvm_value_to_index);
      
      llvm_layout_pointer := self.emit_temporary(routine_context, layout_pointer_type, make_temp_name(routine_context));
      llvm_layout_pointer_data_pointer := self.emit_gep_value_data(self.builder, routine_context, llvm_layout_pointer_type, llvm_layout_pointer);
      self.emit_store_raw(llvm_layout_pointer_data_pointer, llvm_value_to_index_data);
      llvm_layout_pointer_index_pointer := self.emit_gep_value_length(self.builder, routine_context, llvm_layout_pointer_type, llvm_layout_pointer);
      self.emit_store_raw(llvm_layout_pointer_index_pointer, llvm_index);

      if (routine_context.current_loading_mode == .Load_Address) {
        return llvm_layout_pointer;
      } else {
        return self.emit_load(routine_context, layout_pointer_type, llvm_layout_pointer);
      }
    }
  }

  /**
  * Emit a regular unary expression.
  * 
  * @param routine_context  The context of the routine.
  * @param expression_unary The expression to emit.
  * @param type             The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_unary_regular(routine_context: *Routine_Context, expression: *Expression_Unary, type: *Type) -> LLVMValueRef {
    operator := expression.operator;
    type := type;

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
    llvm_value := self.emit_expression(routine_context, cast(*Expression) expression.expression, type);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    // We handle enums as their base types.
    if (type.is_enumeration()) {
      type = type.base;
    }

    llvm_result: LLVMValueRef;
    if (type.is_integer() || type.is_float()) {
      switch (operator) {
        case .Add: {
          // The single unary '+' operator does not do anything to the value.
          llvm_result = llvm_value;
        }
        case .Subtract: {
          if (type.is_integer()) {
            llvm_result = LLVMBuildNeg(self.builder, llvm_value, make_value_name(routine_context));
          } else if (type.is_float()) {
            llvm_result = LLVMBuildFNeg(self.builder, llvm_value, make_value_name(routine_context));
          }
        }
        case .Negate: {
          if (type.is_integer()) {
            // The '~' operator is equivalent to the '*' operator with all ones: ~x == 0xFFFFFFFF * x
            llvm_type := self.type_to_llvm(type);
            llvm_result = LLVMBuildXor(self.builder, LLVMConstAllOnes(llvm_type), llvm_value, make_value_name(routine_context));
          }
        }
      }
    } else if (type.is_boolean()) {
      assert(operator == .Not);
      llvm_result = LLVMBuildNot(self.builder, llvm_value, make_value_name(routine_context));
    }

    if (routine_context.current_loading_mode == .Load_Address) {
      return self.emit_temporary_and_store_raw(routine_context, type, llvm_result, make_temp_name(routine_context));
    } else {
      return llvm_result;
    }
  }

  /**
  * Emit a binary expression.
  * 
  * @param routine_context  The context of the routine.
  * @param expression        The expression to emit.
  * @param type             The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_binary(routine_context: *Routine_Context, expression: *Expression, type: *Type) -> LLVMValueRef {
    expression := cast(*Expression_Binary) expression;
    operator := expression.operator;

    llvm_result: LLVMValueRef;
    switch (operator) {
      case .Multiply, .Divide, .Modulo: fallthrough;
      case .Add, .Subtract, .Left_Shift, .Right_Shift: fallthrough;
      case .And, .Or, .Xor: llvm_result = self.emit_expression_binary_arithmetic(routine_context, expression, type);

      case .Equal, .Not_Equal: fallthrough;
      case .Less_Than, .Less_Than_Equal, .Greater_Than, .Greater_Than_Equal: llvm_result = self.emit_expression_binary_comparison(routine_context, expression);

      case .And_And, .Or_Or: llvm_result = self.emit_expression_binary_short_circuit(routine_context, expression, type);
    }

    if (routine_context.current_loading_mode == .Load_Address) {
      return self.emit_temporary_and_store_raw(routine_context, type, llvm_result, make_temp_name(routine_context));
    } else {
      return llvm_result;
    }
  }

  /**
  * Emit a binary arithmetic expression.
  * 
  * @param routine_context   The context of the routine.
  * @param expression_binary The expression to emit.
  * @param type              The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_binary_arithmetic(routine_context: *Routine_Context, expression: *Expression_Binary, type: *Type) -> LLVMValueRef {
    left_expression := cast(*Expression) expression.left;
    right_expression := cast(*Expression) expression.right;

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
    llvm_value_left := self.emit_expression(routine_context, left_expression, type);
    llvm_value_right := self.emit_expression(routine_context, right_expression, type);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    left_type := self.get_resolved_type(left_expression);
    right_type := self.get_resolved_type(right_expression);

    return self.emit_expression_binary_arithmetic_operation(routine_context, expression.operator, left_type, llvm_value_left, right_type, llvm_value_right);
  }

  /**
  * Emit a binary arithmetic operation.
  * 
  * @param routine_context   The context of the routine.
  * @param operator          The binary operator.
  * @param left_type         The type of the left operand.
  * @param llvm_value_left   The left LLVM value.
  * @param right_type        The type of the right operand.
  * @param llvm_value_right  The right LLVM value.
  * @return The value of the expression.
  */
  internal proc emit_expression_binary_arithmetic_operation(
    routine_context: *Routine_Context,
    operator: Token_Kind,
    left_type: *Type,
    llvm_value_left: LLVMValueRef,
    right_type: *Type,
    llvm_value_right: LLVMValueRef,
  ) -> LLVMValueRef {
    is_doing_pointer_arithemtic := (left_type.is_absolute_pointer_like() && right_type.is_offset_relative_pointer())
      || (left_type.is_offset_relative_pointer() && right_type.is_absolute_pointer_like())
      || (left_type.is_absolute_pointer_like() && right_type.is_absolute_pointer_like());

    if (is_doing_pointer_arithemtic) {
      return self.emit_expression_binary_arithmetic_operation_pointer(routine_context, operator, left_type, llvm_value_left, right_type, llvm_value_right);
    } else {
      return self.emit_expression_binary_arithmetic_operation_regular(routine_context, operator, left_type, llvm_value_left, right_type, llvm_value_right);
    }
  }
  
  /**
  * Emit a pointer binary arithmetic operation.
  * 
  * @param generator         The reference to the generator.
  * @param routine_context   The context of the routine.
  * @param operator          The binary operator.
  * @param left_type         The type of the left operand.
  * @param llvm_value_left   The left LLVM value.
  * @param right_type        The type of the right operand.
  * @param llvm_value_right  The right LLVM value.
  * @return The value of the expression.
  */
  private proc emit_expression_binary_arithmetic_operation_pointer(
    routine_context: *Routine_Context,
    operator: Token_Kind,
    left_type: *Type,
    llvm_value_left: LLVMValueRef,
    right_type: *Type,
    llvm_value_right: LLVMValueRef,
  ) -> LLVMValueRef {
    switch (operator) {
      case .Add: {
        absolute_pointer_type: *Type;
        llvm_pointer_value: LLVMValueRef;
        llvm_offset_relative_pointer_value: LLVMValueRef;
        if (left_type.is_absolute_pointer_like()) {
          absolute_pointer_type = left_type;
          llvm_pointer_value = llvm_value_left;
          llvm_offset_relative_pointer_value = llvm_value_right;
        } else {
          absolute_pointer_type = right_type;
          llvm_pointer_value = llvm_value_right;
          llvm_offset_relative_pointer_value = llvm_value_left;
        }

        llvm_base_type := self.type_to_llvm(absolute_pointer_type.base);
        llvm_added_pointer := self.emit_gep_pointer(self.builder, routine_context, llvm_base_type, llvm_pointer_value, llvm_offset_relative_pointer_value);
        return LLVMBuildIntToPtr(self.builder, llvm_added_pointer, self.type_to_llvm(absolute_pointer_type), make_value_name(routine_context));
      }
      case .Subtract: {
        llvm_left_int_pointer := LLVMBuildPtrToInt(self.builder, llvm_value_left, LLVMInt64Type(), make_value_name(routine_context));
        llvm_right_int_pointer := LLVMBuildPtrToInt(self.builder, llvm_value_right, LLVMInt64Type(), make_value_name(routine_context));
        llvm_pointer_difference := LLVMBuildSub(self.builder, llvm_left_int_pointer, llvm_right_int_pointer, make_value_name(routine_context));
        // Because offset-relative pointers store the difference in TYPE UNITS and not bytes, we have to do the conversion here.
        // That means dividing the byte offset by the size of the base type.
        return LLVMBuildSDiv(
          self.builder,
          llvm_pointer_difference,
          LLVMConstInt(LLVMInt64Type(), cast(u64) left_type.get_size(), false),
          make_value_name(routine_context),
        );
      }
    }

    assert(false);
    return null;
  }

  /**
  * Emit a regular binary arithmetic operation.
  * 
  * @param routine_context   The context of the routine.
  * @param operator          The binary operator.
  * @param left_type         The type of the left operand.
  * @param llvm_value_left   The left LLVM value.
  * @param right_type        The type of the right operand.
  * @param llvm_value_right  The right LLVM value.
  * @return The value of the expression.
  */
  private proc emit_expression_binary_arithmetic_operation_regular(
    routine_context: *Routine_Context,
    operator: Token_Kind,
    left_type: *Type,
    llvm_value_left: LLVMValueRef,
    right_type: *Type,
    llvm_value_right: LLVMValueRef,
  ) -> LLVMValueRef {
    // Here we know that 'type' will be the same for both left and right operands (except shifts).
    type := left_type;
    if (type.is_enumeration()) {
      type = type.base;
    } else if (type.is_offset_relative_pointer()) {
      type = (cast(*Type_Relative_Pointer) type).relative_base;
    }

    name := make_value_name(routine_context);

    switch (operator) {
      case .Multiply: {
        switch (type.kind) {
          case .I8, .I16, .I32, .I64, .Int, .Untyped_Integer: fallthrough;
          case .U8, .U16, .U32, .U64, .UInt: return LLVMBuildMul(self.builder, llvm_value_left, llvm_value_right, name);
          case .F32, .F64, .Untyped_Float:   return LLVMBuildFMul(self.builder, llvm_value_left, llvm_value_right, name);
        }
      }
      case .Divide: {
        switch (type.kind) {
          case .I8, .I16, .I32, .I64, .Int, .Untyped_Integer: return LLVMBuildSDiv(self.builder, llvm_value_left, llvm_value_right, name);
          case .U8, .U16, .U32, .U64, .UInt: return LLVMBuildUDiv(self.builder, llvm_value_left, llvm_value_right, name);
          case .F32, .F64, .Untyped_Float:   return LLVMBuildFDiv(self.builder, llvm_value_left, llvm_value_right, name);
        }
      }
      case .Modulo: {
        switch (type.kind) {
          case .I8, .I16, .I32, .I64, .Int, .Untyped_Integer: return LLVMBuildSRem(self.builder, llvm_value_left, llvm_value_right, name);
          case .U8, .U16, .U32, .U64, .UInt: return LLVMBuildURem(self.builder, llvm_value_left, llvm_value_right, name);
        }
      }
      case .Add: {
        switch (type.kind) {
          case .I8, .I16, .I32, .I64, .Int, .Untyped_Integer: fallthrough;
          case .U8, .U16, .U32, .U64, .UInt: return LLVMBuildAdd(self.builder, llvm_value_left, llvm_value_right, name);
          case .F32, .F64, .Untyped_Float:   return LLVMBuildFAdd(self.builder, llvm_value_left, llvm_value_right, name);
        }
      }
      case .Subtract: {
        switch (type.kind) {
          case .I8, .I16, .I32, .I64, .Int, .Untyped_Integer: fallthrough;
          case .U8, .U16, .U32, .U64, .UInt: return LLVMBuildSub(self.builder, llvm_value_left, llvm_value_right, name);
          case .F32, .F64, .Untyped_Float:   return LLVMBuildFSub(self.builder, llvm_value_left, llvm_value_right, name);
        }
      }

      case .Left_Shift: {
        llvm_value_right := self.emit_expression_binary_shit_type_extension(routine_context, left_type, right_type, llvm_value_right);
        return LLVMBuildShl(self.builder, llvm_value_left, llvm_value_right, name);
      } 
      case .Right_Shift: {
        llvm_value_right := self.emit_expression_binary_shit_type_extension(routine_context, left_type, right_type, llvm_value_right);
        return LLVMBuildLShr(self.builder, llvm_value_left, llvm_value_right, name);
      }

      case .And: return LLVMBuildAnd(self.builder, llvm_value_left, llvm_value_right, name);
      case .Or:  return LLVMBuildOr(self.builder, llvm_value_left, llvm_value_right, name);
      case .Xor: return LLVMBuildXor(self.builder, llvm_value_left, llvm_value_right, name);
    }

    assert(false);
    return null;  
  }

  /**
  * Emit a comparison binary expression.
  * 
  * @param generator         The reference to the generator.
  * @param routine_context   The context of the routine.
  * @param expression_binary The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_binary_comparison(routine_context: *Routine_Context, expression: *Expression_Binary) -> LLVMValueRef {
    // We explicitly request the type of the lhs and rhs expressions here as the result will always be a boolean.
    type := self.get_resolved_type(cast(*Expression) expression.left);
    if (type.is_enumeration()) {
      type = type.base;
    }

    // There are some types where need the address of the type and not its simple value.
    needs_to_load_address := type.is_self_relative_pointer() || type.is_dynamic_pointer() || type.is_string() || type.is_union();
    previous_loading_mode := self.enter_loading_mode(routine_context, needs_to_load_address ? .Load_Address : .Load_Value);
    llvm_value_left := self.emit_expression(routine_context, cast(*Expression) expression.left, type);
    llvm_value_right := self.emit_expression(routine_context, cast(*Expression) expression.right, type);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    switch (type.kind) {
      case .B8, .B16, .B32, .B64, .Bool: fallthrough;
      case .I8, .I16, .I32, .I64, .Int, .Untyped_Integer: fallthrough;
      case .U8, .U16, .U32, .U64, .UInt: fallthrough;
      case .Char, .Untyped_Char: fallthrough;
      case .Rawptr, .Pointer, .Self_Relative_Pointer, .Offset_Relative_Pointer, .Dynamic_Pointer: fallthrough;
      // Pointers are treated as integers by the icmp instruction.
      case .Procedure, .Function: fallthrough; // Routines are represented as pointers.
      case .Typeid, .Untyped_Null: {
        if (type.is_self_relative_pointer()) {
          // When comparing self-relative pointers we actually compare the absolute pointers they compute to.
          // That means we have to explicitly skip the compuation when comparing with the constant 'null'.
          // Because in that case we do actually compare the offset value stored in the pointer.
          if (LLVMIsConstant(llvm_value_left) || LLVMIsConstant(llvm_value_right)) {
            relative_base := (cast(*Type_Relative_Pointer) type).relative_base;
            // Because we previously requested the pointer when emitting the expressions in the case of self-relative pointers,
            // we know we have to manually do the loading of the offset value when comparing with 'null'.
            // This is also the reason why we get the self.default_initializer_value for the relative base.
            // We want to compare the integer offset to the integer constant '0' otherwise we would compare with 'null'.
            llvm_pointer_to_load := LLVMIsConstant(llvm_value_left) ? llvm_value_right : llvm_value_left;
            llvm_loaded_value := self.emit_load(routine_context, relative_base, llvm_pointer_to_load);
            if (LLVMIsConstant(llvm_value_left)) {
              llvm_value_right = llvm_loaded_value;
              llvm_value_left = self.default_initializer_value(relative_base);
            } else {
              llvm_value_left = llvm_loaded_value;
              llvm_value_right = self.default_initializer_value(relative_base);
            }
          } else {
            llvm_value_left = self.emit_self_relative_pointer_to_absolute(routine_context, type, llvm_value_left);
            llvm_value_right = self.emit_self_relative_pointer_to_absolute(routine_context, type, llvm_value_right);
          }
        } else if (type.is_dynamic_pointer()) {
          if (LLVMIsConstant(llvm_value_left)) {
            llvm_value_left = LLVMConstNull(LLVMPointerType(LLVMVoidType(), 0));
          } else {
            llvm_value_left = self.emit_gep_value_data(self.builder, routine_context, self.type_to_llvm(type), llvm_value_left);
            llvm_value_left = self.emit_load(routine_context, context.storage.type_rawptr, llvm_value_left);
          }
          if (LLVMIsConstant(llvm_value_right)) {
            llvm_value_right = LLVMConstNull(LLVMPointerType(LLVMVoidType(), 0));
          } else {
            llvm_value_right = self.emit_gep_value_data(self.builder, routine_context, self.type_to_llvm(type), llvm_value_right);
            llvm_value_right = self.emit_load(routine_context, context.storage.type_rawptr, llvm_value_right);
          }
        }

        llvm_operator: LLVMIntPredicate;
        switch (expression.operator) {
          case .Equal: llvm_operator = .EQ;
          case .Not_Equal: llvm_operator = .NE;
          case .Less_Than: llvm_operator = type.is_unsigned() ? .ULT : .SLT;
          case .Less_Than_Equal: llvm_operator = type.is_unsigned() ? .ULE : .SLE;
          case .Greater_Than: llvm_operator = type.is_unsigned() ? .UGT : .SGT;
          case .Greater_Than_Equal: llvm_operator = type.is_unsigned() ? .UGE : .SGE;
          case: assert(false);
        }

        return LLVMBuildICmp(self.builder, llvm_operator, llvm_value_left, llvm_value_right, make_value_name(routine_context));
      }

      case .F32, .F64, .Untyped_Float: {
        llvm_operator: LLVMRealPredicate;
        switch (expression.operator) {
          case .Equal: llvm_operator = .UEQ;
          case .Not_Equal: llvm_operator = .UNE;
          case .Less_Than: llvm_operator = .ULT;
          case .Less_Than_Equal: llvm_operator = .ULE;
          case .Greater_Than: llvm_operator = .UGT;
          case .Greater_Than_Equal: llvm_operator = .UGE;
          case: assert(false);
        }

        return LLVMBuildFCmp(self.builder, llvm_operator, llvm_value_left, llvm_value_right, make_value_name(routine_context));
      }

      case .CString: {
        if (LLVMIsNull(llvm_value_left) || LLVMIsNull(llvm_value_right)) {
          llvm_operator: LLVMIntPredicate;
          switch (expression.operator) {
            case .Equal: llvm_operator = .EQ;
            case .Not_Equal: llvm_operator = .NE;
            case: assert(false);
          }
          return LLVMBuildICmp(self.builder, llvm_operator, llvm_value_left, llvm_value_right, make_value_name(routine_context));
        } else {
          llvm_arguments: []LLVMValueRef = {llvm_value_left, llvm_value_right};
          llvm_comparison_value := self.emit_call_to_builtin_routine(.Compare_CString, llvm_arguments, make_value_name(routine_context));
          switch (expression.operator) {
            case .Equal: return llvm_comparison_value;
            case .Not_Equal: return LLVMBuildNot(self.builder, llvm_comparison_value, make_value_name(routine_context));
            case: assert(false);
          }
        }
      }
      case .String, .Untyped_String: {
        // For string literals we first have to create a temporaray that we can pass in as a pointer.
        if (LLVMIsConstant(llvm_value_left)) {
          llvm_value_left = self.emit_temporary_and_store_raw(routine_context, context.storage.type_string, llvm_value_left, make_byval_name(routine_context));
        }
        if (LLVMIsConstant(llvm_value_right)) {
          llvm_value_right = self.emit_temporary_and_store_raw(routine_context, context.storage.type_string, llvm_value_right, make_byval_name(routine_context));
        }

        llvm_arguments: []LLVMValueRef = {llvm_value_left, llvm_value_right};
        llvm_comparison_value := self.emit_call_to_builtin_routine(.Compare_String, llvm_arguments, make_value_name(routine_context));
        switch (expression.operator) {
          case .Equal: return llvm_comparison_value;
          case .Not_Equal: return LLVMBuildNot(self.builder, llvm_comparison_value, make_value_name(routine_context));
          case: assert(false);
        }
      }

      case .Union: {
        llvm_union_value := LLVMIsNull(llvm_value_left) ? llvm_value_right : llvm_value_left;
        llvm_union_type := self.type_to_llvm(type);
        llvm_union_tag_pointer := self.emit_gep_union_tag(self.builder, routine_context, llvm_union_type, llvm_union_value);
        llvm_union_tag := self.emit_load(routine_context, context.storage.type_int, llvm_union_tag_pointer);
        llvm_operator: LLVMIntPredicate;
        switch (expression.operator) {
          case .Equal: llvm_operator = .EQ;
          case .Not_Equal: llvm_operator = .NE;
          case: assert(false);
        }
        return LLVMBuildICmp(self.builder, llvm_operator, llvm_union_tag, LLVMConstInt(LLVMInt64Type(), 0, false), make_value_name(routine_context));
      }
    }

    assert(false);
    return null;
  }

  /** 
  * Emit a short circuit binary expression.
  * 
  * @param generator         The reference to the generator.
  * @param routine_context   The context of the routine.
  * @param expression_binary The expression to emit.
  * @param type              The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_binary_short_circuit(routine_context: *Routine_Context, expression: *Expression_Binary, type: *Type) -> LLVMValueRef {
    // NOTE: We have to be VERY careful about the order we append the blocks here.

    is_logical_and := expression.operator == .And_And;

    llvm_value_left := self.emit_boolean_truncation(routine_context, cast(*Expression) expression.left, type);
    first_comparison_block := routine_context.current_block;

    // We first generate the short circuit block containing all other expressions.
    short_circuit_block := self.append_block(routine_context);
    previous_block := self.enter_llvm_block(routine_context, short_circuit_block);
    llvm_value_right := self.emit_boolean_truncation(routine_context, cast(*Expression) expression.right, type);
    last_after_block := routine_context.current_block;
    self.leave_llvm_block(routine_context, previous_block);

    after_block := self.append_block(routine_context);

    previous_block = self.enter_llvm_block(routine_context, last_after_block);
    LLVMBuildBr(self.builder, after_block);
    self.leave_llvm_block(routine_context, previous_block);

    previous_block = self.enter_llvm_block(routine_context, first_comparison_block);
    LLVMBuildCondBr(self.builder, llvm_value_left, is_logical_and ? short_circuit_block : after_block, is_logical_and ? after_block : short_circuit_block);
    self.leave_llvm_block(routine_context, previous_block);

    current_block := routine_context.current_block;
    self.enter_llvm_block(routine_context, after_block);

    llvm_phi_value := LLVMBuildPhi(self.builder, LLVMInt1Type(), make_value_name(routine_context));
    llvm_phi_incoming_values: []LLVMValueRef = {LLVMConstInt(LLVMInt1Type(), is_logical_and ? 0 : 1, false), llvm_value_right};
    llvm_phi_incoming_blocks: []LLVMBasicBlockRef = {current_block, last_after_block};
    LLVMAddIncoming(llvm_phi_value, data(llvm_phi_incoming_values), data(llvm_phi_incoming_blocks), 2);

    return llvm_phi_value;
  }
  
  /**
  * Emit a ternary expression.
  * 
  * @param generator       The reference to the generator.
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @param type            The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_ternary(routine_context: *Routine_Context, expression: *Expression, type: *Type) -> LLVMValueRef {
    expression_ternary := cast(*Expression_Ternary) expression;

    llvm_then_block := self.append_block(routine_context);
    llvm_else_block := self.append_block(routine_context);
    llvm_after_block := self.append_block(routine_context);

    is_union := type.is_union();

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);

    llvm_conditional_value := self.emit_boolean_truncation(routine_context, cast(*Expression) expression_ternary.condition, context.storage.type_bool);
    LLVMBuildCondBr(self.builder, llvm_conditional_value, llvm_then_block, llvm_else_block);

    then_expression := cast(*Expression) expression_ternary.then_expression;
    previous_block := self.enter_llvm_block(routine_context, llvm_then_block);
    then_type := is_union ? self.get_resolved_type(then_expression) : type;
    llvm_then_value := self.emit_expression(routine_context, then_expression, then_type);
    if (is_union && type != then_type) {
      llvm_then_value_temporary := self.emit_temporary(routine_context, type, make_temp_name(routine_context));
      self.emit_store_union(routine_context, type, llvm_then_value_temporary, llvm_then_value, then_expression);
      llvm_then_value = self.emit_load(routine_context, type, llvm_then_value_temporary);
    }
    LLVMBuildBr(self.builder, llvm_after_block);
    self.leave_llvm_block(routine_context, previous_block);

    else_expression := cast(*Expression) expression_ternary.else_expression;
    previous_block = self.enter_llvm_block(routine_context, llvm_else_block);
    else_type := is_union ? self.get_resolved_type(else_expression) : type;
    llvm_else_value := self.emit_expression(routine_context, else_expression, else_type);
    if (is_union && type != else_type) {
      llvm_else_value_temporary := self.emit_temporary(routine_context, type, make_temp_name(routine_context));
      self.emit_store_union(routine_context, type, llvm_else_value_temporary, llvm_else_value, else_expression);
      llvm_else_value = self.emit_load(routine_context, type, llvm_else_value_temporary);
    }
    LLVMBuildBr(self.builder, llvm_after_block);
    self.leave_llvm_block(routine_context, previous_block);

    self.leave_loading_mode(routine_context, previous_loading_mode);

    self.enter_llvm_block(routine_context, llvm_after_block);

    llvm_type := self.type_to_llvm(type);
    llvm_ternary_value := LLVMBuildPhi(self.builder, llvm_type, make_value_name(routine_context));
    llvm_phi_incoming_values: []LLVMValueRef = {llvm_then_value, llvm_else_value};
    llvm_phi_incoming_bocks: []LLVMBasicBlockRef = {llvm_then_block, llvm_else_block};
    LLVMAddIncoming(llvm_ternary_value, data(llvm_phi_incoming_values), data(llvm_phi_incoming_bocks), cast(u32) length(llvm_phi_incoming_values));

    if (routine_context.current_loading_mode == .Load_Address) {
      return self.emit_temporary_and_store_raw(routine_context, type, llvm_ternary_value, make_temp_name(routine_context));
    } else {
      return llvm_ternary_value;
    }
  }
  
  /**
  * Emit a modify expression.
  * 
  * @param generator       The reference to the generator.
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @param type            The type of the expression.
  * @return The value of the expression.
  */
  private proc emit_expression_modify(routine_context: *Routine_Context, expression: *Expression, type: *Type) -> LLVMValueRef {
    expression := cast(*Expression_Modify) expression;

    operator := expression.operator;
    modify_expression := cast(*Expression) expression.expression;

    previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Address);
    llvm_value_pointer := self.emit_expression(routine_context, modify_expression, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    // Load the value from the pointer.
    llvm_type := self.type_to_llvm(type);
    previous_loading_mode = self.enter_loading_mode(routine_context, .Load_Value);
    llvm_value_to_modify := self.emit_expression(routine_context, modify_expression, null);
    self.leave_loading_mode(routine_context, previous_loading_mode);

    llvm_modify_constant := LLVMConstInt(llvm_type, 1, false);
    
    // Modify the value.
    llvm_modified_value: LLVMValueRef;
    if (operator == .Increment) {
      llvm_modified_value = LLVMBuildAdd(self.builder, llvm_value_to_modify, llvm_modify_constant, make_value_name(routine_context));
    } else {
      assert(operator == .Decrement);
      llvm_modified_value = LLVMBuildSub(self.builder, llvm_value_to_modify, llvm_modify_constant, make_value_name(routine_context));
    }

    // Now store the modified value back.
    // We can use 'self.emit_store_raw' here as we will never have to deal with self-relative pointers here.
    self.emit_store_raw(llvm_value_pointer, llvm_modified_value);

    // Return the corresponding value.
    if (expression.is_post) {
      // Post increment/decrement just returns the value not modified.
      return llvm_value_to_modify;
    } else {
      return llvm_modified_value;
    }
  }

  /**
  * Emit a query expression.
  * 
  * @param generator       The reference to the generator.
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_query(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    expression := cast(*Expression_Query) expression;

    switch (expression.query_kind) {
      case .Size_Of_Expression, .Size_Of_Type, .Typeid_Of_Expression, .Typeid_Of_Type: {
        if (expression.query_kind == .Typeid_Of_Expression) {
          query_expression := expression.value.(*Expression);
          expression_type := self.get_resolved_type(query_expression);
          if (expression_type.is_any()) {
            return self.emit_typeid_expression_any(routine_context, query_expression);
          } else if (expression_type.is_union()) {
            return self.emit_typeid_expression_union(routine_context, query_expression, expression_type);
          }
        }

        constant, found := self.get_resolved_constant(cast(*Expression) expression);
        assert(found);
        return LLVMConstInt(LLVMInt64Type(), cast(u64) constant.value.(uint), false);
      }
      case .Type_Info_Of_Expression, .Type_Info_Of_Type: {
        llvm_index: LLVMValueRef; 
        if (expression.query_kind == .Type_Info_Of_Expression) {
          // For expressions we need to dynamically lookup the actual type info index in the indices table.
          previous_loading_mode := self.enter_loading_mode(routine_context, .Load_Value);
          llvm_type_info_indices_index := self.emit_expression(routine_context, expression.value.(*Expression), null);
          self.leave_loading_mode(routine_context, previous_loading_mode);
          llvm_type_info_indices_index_pointer := self.emit_gep_field_dynamic(
            self.builder,
            routine_context,
            self.llvm_type_info_table_indices_map_type,
            self.llvm_type_info_table_indices_map,
            llvm_type_info_indices_index,
          );
          llvm_index = self.emit_load(routine_context, context.storage.type_uint, llvm_type_info_indices_index_pointer);
        } else {
          constant, found_constant := self.get_resolved_constant(cast(*Expression) expression);
          assert(found_constant);

          // Constants can directly be converted to the proper table index.
          index, found_index := map_get(&self.type_info_table_indices, constant.value.(uint));
          assert(found_index);
          llvm_index = LLVMConstInt(LLVMInt32Type(), index, false);
        }

        llvm_type_info_pointer := self.emit_gep_field_dynamic(
          self.builder,
          routine_context,
          self.llvm_type_info_table_type,
          self.llvm_type_info_table,
          llvm_index,
        );

        if (routine_context.current_loading_mode == .Load_Address) {
          type_info_pointer_type := context.storage.get_or_make_type_pointer(context.storage.cached_runtime_types.type_info);
          llvm_type_info_pointer_temporary := self.emit_temporary(routine_context, type_info_pointer_type, make_temp_name(routine_context));
          self.emit_store_raw(llvm_type_info_pointer_temporary, llvm_type_info_pointer);
          return llvm_type_info_pointer_temporary;
        } else {
          return llvm_type_info_pointer;
        }
      }
    }

    assert(false);
    return null;
  }
  
  /**
  * Emit a directive expression.
  * 
  * @param generator       The reference to the generator.
  * @param routine_context The context of the routine.
  * @param expression      The expression to emit.
  * @return The value of the expression.
  */
  private proc emit_expression_directive(routine_context: *Routine_Context, expression: *Expression) -> LLVMValueRef {
    directive_kind := (cast(*Expression_Directive) expression).directive_kind;
    return self.emit_expression_directive_constant(routine_context, directive_kind, expression.position);
  }

  /**
  * Emit a constant directive expression.
  * 
  * @param generator       The reference to the generator.
  * @param routine_context The context of the routine.
  * @param kind            The directive expression kind.
  * @param position        The position of the directive expression.
  * @return The value of the expression.
  */
  private proc emit_expression_directive_constant(routine_context: *Routine_Context, kind: Expression_Directive_Kind, position: Source_Position) -> LLVMValueRef {
    storage := context.storage;

    switch (kind) {
      case .Line: return self.constant_to_llvm(cast(int) position.line, storage.type_int);
      case .Routine: {
        // The symbol of the procedure context may be null if we are currently emitting a global initializer.
        routine_name := "";
        if (routine_context.symbol != null) {
          routine_name = routine_context.symbol.name;
        }
        return self.constant_to_llvm(routine_name, storage.type_string);
      }
      case .File: return self.constant_to_llvm(position.file, storage.type_string);
      case .Location: {
        llvm_line := self.constant_to_llvm(cast(int) position.line, storage.type_int);
        routine_name := "";
        if (routine_context.symbol != null) {
          routine_name = routine_context.symbol.name;
        }
        llvm_procedure_name := self.constant_to_llvm(routine_name, storage.type_string);
        llvm_file := self.constant_to_llvm(position.file, storage.type_string);

        llvm_location_elements: []LLVMValueRef = {llvm_line, llvm_procedure_name, llvm_file};
        return LLVMConstStruct(data(llvm_location_elements), cast(u32) length(llvm_location_elements), false);
      }
    }

    assert(false);
    return null;
  }

}