import "std:memory"
import "std:strings"
import "std:system"

/**
* Represents the kind of a type.
* (NOTE: The order of this is not arbitrary as it gets used in '<' and '>' comparisons.)
*/
internal enum Type_Kind {
  None,

  Void,

  B8,
  B16,
  B32,
  B64,
  Bool,
  Untyped_Boolean,

  I8,
  I16,
  I32,
  I64,
  Int,
  U8,
  U16,
  U32,
  U64,
  UInt,
  Untyped_Integer,

  F32,
  F64,
  Untyped_Float,

  Char,
  Untyped_Char,

  Enumeration,

  String,
  CString,
  Untyped_String,

  Rawptr,
  Pointer,
  Self_Relative_Pointer,
  Offset_Relative_Pointer,
  SoA_Layout_Pointer,
  AoSoA_Layout_Pointer,
  Dynamic_Pointer,

  Constant,
  Array,
  Dynamic_Array,
  Slice,
  Map,
  Tuple,

  Struct,
  Union,

  Procedure,
  Function,

  Interface,

  Any,
  Typeid,

  Untyped_Null,

  Generic,
}

/**
* The state for a type.
*/
internal enum Type_State {
  Incomplete, // The type is incomplete (Only possible for structs and unions).
  Completing, // The type is currently completing (Only possible for structs and unions).
  Completed,  // The type is completed.
}

internal type_alias Type_Id := uint;

/**
* Represents possible flags for a type.
*/
@flags internal enum Type_Flags : u32 {
  Non_Modifiable,                            // For types that cannot be modified through '++' or '--'.
  
  Not_Allowed_As_Pointer,                    // For types that are not allowed to be pointers.
  Not_Allowed_As_Base,                       // For types that are not allowed to be a base of arrays, slices and tuples.
  Not_Allowed_As_Field,                      // For types that are not allowed as struct fields.
  Not_Allowed_As_Tuple,                      // For types that are not allowed as tuple elements.
  Not_Allowed_As_Union,                      // For types that are not allowed to be part of unions.
  Not_Allowed_As_Variable,                   // For types that are not allowed as local/global variables.
  Not_Allowed_As_Parameter_Or_Return_Type,   // For types that are not allowed as parameters or return type.
  Not_Allowed_As_Parameter_In_Pure_Function, // For types that are not allowed as parameters in pure functions.
  
  Has_Hash_Function,                         // The type has a simple function that can generate a hash from a value of the type.
  Has_Compare_Function,                      // The type has a simple function that can determine if two values from the type are equal.

  Uninstantiated_Generic,                    // For uninstantiated generic types.
  Defined_Distinct,                          // For types that are created through 'type_define' declarations.
  Interface_Used_In_Dynamic_Pointer,         // For interfaces that are used as the base of a dynamic pointer.

  // Those are pretty much only relevant inside the generator.
  Generate_RTTR,                             // Generate runtime type information for this type in the type table.
  Contains_Self_Relative_Pointer_In_Value,   // For types that contain self-relative pointers inside their actual value (pointers or slices don't for example).
  Passed_As_Pointer,                         // For types that are passed as pointers to routines.
  Requires_Address_Load,                     // For types that require the 'Loading_Address' loading mode when generating.
}

/**
* The type for a collection.
*/
internal enum Collection_Type {
  None,
  Array,
  Dynamic_Array,
  Slice,
}

/**
* Layout information for a collection.
*/
internal struct Layout_Info {
  modifier: Layout_Modifier, // The layout modifier.
  items_in_aosoa_chunk: int, // The number of items in an AoSoA chunk (Only relevant for an AoSoA layout).
}

/**
* Default layout info with no special layout.
*/
internal global SOA_INFO_NONE := Layout_Info{.None, 0};

/**
* Represents the size for the L1 cache line in bytes.
* This gets set programmatically at startup (Should be 64 bytes on most CPUs).
*/
internal global L1_CACHE_LINE_SIZE: uint;

/**
* Base structure for representing a type.
*/
internal struct Type {
  kind: Type_Kind,                    // The kind of the type.
  state: Type_State,                  // The state of the type.
  flags: Type_Flags,                  // The flags of the type.
  id: Type_Id,                        // The id of the type.

  size: uint,                         // The size of the type in bytes.
  alignment: uint,                    // The alignment of the type in bytes.

  name: string,                       // The name of the type.
  symbol: *Symbol,                    // The symbol that defines the type (Not present for built-in types).

  base: *Type,                        // The base type for the type (Used for example in all pointer kinds and collections).
  methods: aosoa[dynamic]Type_Method, // All methods implemented for the type.
  interfaces: [dynamic]*Type,         // All interfaces the type implements.
}

/**
* Represents a method implemented on a type.
*/
internal struct Type_Method {
  access_modifier: Access_Modifier, // The access modifier of the method.

  // Because methods for a type can currently be implemented in ANY package/file, we have to store that position information here.
  // That way we can properly do the access check for the method unrelated to the position where the type was defined.
  package: *Package,                // The package where the method is implemented.
  file: string,                     // The file where the method is implemented.
  
  name: string,                     // The name of the method.
  type: *Type,                      // The type of the method.
}

/**
* Represents an enumeration type.
*/
internal struct Type_Enumeration {
  composite type: Type,                       // The base type info.
  items: aosoa[dynamic]Type_Enumeration_Item, // The items of the enum.
  is_flags: bool,                             // Is the enumeration defined with the '@flags' attribute?
}

/**
* Represents a single item for an enumeration type.
*/
internal struct Type_Enumeration_Item {
  name: string, // The name of the item.
  value: Value, // The constant value of the item (Will always be an integer type).
}

/**
* Represents a relative pointer type.
*/
internal struct Type_Relative_Pointer {
  composite type: Type, // The base type info.
  relative_base: *Type, // The relative base type used to represent the relative offset.
}

/**
* Represents an array type.
*/
internal struct Type_Array {
  composite type: Type,          // The base type info.
  layout_info: Layout_Info,      // The layout info of the array.
  number_of_elements: int,       // The number of elements of the array (Will be 0 for incomplete arrays).
  has_incomplete_elements: bool, // Is the array incomplete (Has not yet a defined size)?
}

/**
* Represents a dynamic array type.
*/
internal struct Type_Dynamic_Array {
  composite type: Type,     // The base type info.
  layout_info: Layout_Info, // The layout info of the dynamic array.
}

/**
* Represents a slice type.
*/
internal struct Type_Slice {
  composite type: Type,     // The base type info.
  layout_info: Layout_Info, // The layout info of the slice.
}

/**
* Represents a single element of a tuple type.
*/
internal struct Type_Tuple_Element {
  type: *Type,  // The type of the element.
  offset: uint, // The offset of the element.
}

/**
* Represents a map type.
*/
internal struct Type_Map {
  composite type: Type, // The base type info.
  key: *Type,           // The key type of the map.
  value: *Type,         // The value type of the map.
}

/**
* Represents a tuple type.
*/
internal struct Type_Tuple {
  composite type: Type,                       // The base type info.
  elements: aosoa[dynamic]Type_Tuple_Element, // The elements of the tuple.
}

/**
* Represents a struct type.
*/
internal struct Type_Struct {
  composite type: Type,                    // The base type info.
  fields: aosoa[dynamic]Type_Struct_Field, // The fields of the struct.
  layout_info: Layout_Info,                // The layout info of the struct if it is used in an SoA/AoSoA collection.
  generic_types: [dynamic]*Type,           // The generic types of the struct (This is just bookkeeping that we need because structs are initially incomplete).
}

/**
* Represents a single field in a struct type.
*/
internal struct Type_Struct_Field {
  access_modifier: Access_Modifier, // The access modifier of the field.
  is_composite: bool,               // Is the field marked with the 'composite' keyword?
  name: string,                     // The name of the field.
  type: *Type,                      // The type of the field.
  offset: uint,                     // The offset of the field.
}

/**
* Represents a union type.
*/
internal struct Type_Union {
  composite type: Type,     // The base type info.
  variants: [dynamic]*Type, // The variants in the union.
  biggest_type: *Type,      // The biggest type of all variants in the union.
}

/**
* Represents flags for a routine type.
*/
@flags internal enum Type_Routine_Flags {
  Has_Params,       // Has the routine a 'params' parameter?
  Has_C_Varargs,    // Has the routine an c varargs parameter?
  Is_Intrinsic,     // Is the routine an intrinsic?
  Is_Method,        // Is the routine a method?
  Is_Pure_Function, // Is the routine a pure function?
}

/**
* Represents a routine type.
*/
internal struct Type_Routine {
  composite type: Type,                             // The base type info.
  calling_convention: Calling_Convention,           // The calling convention of the routine.
  parameters: aosoa[dynamic]Type_Routine_Parameter, // The parameters of the routine.
  return_type: *Type,                               // The return type of the routine.
  routine_flags: Type_Routine_Flags,                // The flags of the routine type.
}

/**
* Represents a single parameter in a routine type.
*/
internal struct Type_Routine_Parameter {
  type: *Type,      // The type of the parameter.
  is_default: bool, // Is the parameter a default parameter?
}

implement Type {

  /**
  * Get the type without qualifiers.
  * 
  * @return The type without qualifiers.
  */
  internal func unqualify() -> *Type {
    return self.is_constant() ? self.base : self;
  }

  /**
  * Get the type info kind for a type.
  *
  * @return The type info kind corresponding to the type.
  */
  internal func get_type_info_kind() -> Type_Info_Kind {
    switch (self.kind) {
      case .Void: return .Void;

      case .B8, .B16, .B32, .B64, .Bool, .Untyped_Boolean: return .Boolean;
      case .I8, .I16, .I32, .I64, .Int, .U8, .U16, .U32, .U64, .UInt, .Untyped_Integer: return .Integer;
      case .F32, .F64, .Untyped_Float: return .Float;
      case .Char, .Untyped_Char: return .Char;
      case .Enumeration: return .Enumeration;

      case .String, .CString, .Untyped_String: return .String;
      case .Rawptr, .Pointer: return .Pointer;
      case .Self_Relative_Pointer, .Offset_Relative_Pointer: return .Relative_Pointer;
      case .SoA_Layout_Pointer, .AoSoA_Layout_Pointer: return .Layout_Pointer;
      case .Dynamic_Pointer: return .Dynamic_Pointer;
      case .Constant: self.base.get_type_info_kind();

      case .Array: return .Array;
      case .Dynamic_Array: return .Dynamic_Array;
      case .Slice: return .Slice;
      case .Map: return .Map;
      case .Tuple: return .Tuple;

      case .Struct: return .Struct;
      case .Union: return .Union;

      case .Procedure, .Function: return .Routine;

      case .Interface: return .Interface;
      case .Any: return .Any;
      case .Typeid: return .Typeid;
      
      case .None, .Untyped_Null, .Generic: return .Invalid;
    }

    return .Invalid;
  }

  /**
  * Gets the size of a type.
  * 
  * @return The size of the type.
  */
  internal proc get_size() -> uint {
    assert(self.state == .Completed);
    return self.size;
  }

  /**
  * Gets the alignment of a type.
  * 
  * @return The alignment of the type.
  */
  internal proc get_alignment() -> uint {
    assert(self.state == .Completed);
    return self.alignment;
  }

  /**
  * Check whether or not the type is the void type.
  *
  * @return True if the type is the void type otherwise false.
  */
  internal func is_void() -> bool {
    return self.kind == .Void;
  }

  /**
  * Check whether or not the type is a boolean type.
  *
  * @return True if the type is a boolean type otherwise false.
  */
  internal func is_boolean() -> bool {
    return self.kind >= .B8 && self.kind <= .Untyped_Boolean;
  }

  /**
  * Check whether or not the type is an integer type.
  *
  * @return True if the type is an integer type otherwise false.
  */
  internal func is_integer() -> bool {
    return self.kind >= .I8 && self.kind <= .Untyped_Integer;
  }

  /**
  * Check whether or not the type is an unsigned (integer) type.
  *
  * @return True if the type is an unsigned (integer) type otherwise false.
  */
  internal func is_unsigned() -> bool {
    return self.kind >= .U8 && self.kind <= .UInt;
  }

  /**
  * Check whether or not the type is a float type.
  *
  * @return True if the type is a float type otherwise false.
  */
  internal func is_float() -> bool {
    return self.kind >= .F32 && self.kind <= .Untyped_Float;
  }

  /**
  * Check whether or not the type is a char type.
  *
  * @return True if the type is a char type otherwise false.
  */
  internal func is_char() -> bool {
    return self.kind >= .Char && self.kind <= .Untyped_Char;
  }

  /**
  * Check whether or not the type is an enumeration type.
  *
  * @return True if the type is an enumeration type otherwise false.
  */
  internal func is_enumeration() -> bool {
    return self.kind == .Enumeration;
  }

  /**
  * Check whether or not the type is an arithmetic type.
  *
  * @return True if the type is an arithmetic type otherwise false.
  */
  internal func is_arithmetic() -> bool {
    return self.kind >= .I8 && self.kind <= .Untyped_Float || self.is_offset_relative_pointer();
  }

  /**
  * Check whether or not the type is a scalar type.
  *
  * @return True if the type is a scalar type otherwise false.
  */
  internal func is_scalar() -> bool {
    return self.kind >= .B8 && self.kind <= .Enumeration;
  }

  /**
  * Check whether or not the type is a string type.
  *
  * @return True if the type is a string type otherwise false.
  */
  internal func is_string() -> bool {
    return self.kind == .String || self.kind == .Untyped_String;
  }

  /**
  * Check whether or not the type is a cstring type.
  *
  * @return True if the type is a cstring type otherwise false.
  */
  internal func is_cstring() -> bool {
    return self.kind == .CString;
  }

  /**
  * Check whether or not the type is a string like type.
  *
  * @return True if the type is a string like type otherwise false.
  */
  internal func is_string_like() -> bool {
    return self.is_string() || self.is_cstring();
  }

  /**
  * Check whether or not the type is a raw pointer type.
  *
  * @return True if the type is a raw pointer type otherwise false.
  */
  internal func is_raw_pointer() -> bool {
    return self.kind == .Rawptr;
  }

  /**
  * Check whether or not the type is an absolute pointer type.
  *
  * @return True if the type is an absolute pointer type otherwise false.
  */
  internal func is_absolute_pointer() -> bool {
    return self.is_raw_pointer() || self.kind == .Pointer;
  }

  /**
  * Check whether or not the type is an absolute pointer like type.
  *
  * @return True if the type is an absolute pointer like type otherwise false.
  */
  internal func is_absolute_pointer_like() -> bool {
    return self.is_absolute_pointer() || (self.is_routine() && !self.is_routine_intrinsic()) || self.is_untyped_null();
  }

  /**
  * Check whether or not the type is a self-relative pointer type.
  *
  * @return True if the type is a self-relative pointer type otherwise false.
  */
  internal func is_self_relative_pointer() -> bool {
    return self.kind == .Self_Relative_Pointer;
  }

  /**
  * Check whether or not the type is an offset-relative pointer type.
  *
  * @return True if the type is an offset-relative pointer type otherwise false.
  */
  internal func is_offset_relative_pointer() -> bool {
    return self.kind == .Offset_Relative_Pointer;
  }

  /**
  * Check whether or not the type is a relative pointer type.
  *
  * @return True if the type is a relative pointer type otherwise false.
  */
  internal func is_relative_pointer() -> bool {
    return self.is_self_relative_pointer() || self.is_offset_relative_pointer();
  }

  /**
  * Check whether or not the type is an absolute or relative pointer like type.
  *
  * @return True if the type is an absolute or relative pointer like type otherwise false.
  */
  internal func is_absolute_or_relative_pointer_like() -> bool {
    return self.is_absolute_pointer_like() || self.is_relative_pointer();
  }

  /**
  * Check whether or not the type is an SoA layout pointer type.
  *
  * @return True if the type is an SoA layout pointer type otherwise false.
  */
  internal func is_soa_layout_pointer() -> bool {
    return self.kind == .SoA_Layout_Pointer;
  }

  /**
  * Check whether or not the type is an AoSoA layout pointer type.
  *
  * @return True if the type is an AoSoA layout pointer type otherwise false.
  */
  internal func is_aosoa_layout_pointer() -> bool {
    return self.kind == .AoSoA_Layout_Pointer;
  }

  /**
  * Check whether or not the type is a layout pointer type.
  *
  * @return True if the type is a layout pointer type otherwise false.
  */
  internal func is_layout_pointer() -> bool {
    return self.is_soa_layout_pointer() || self.is_aosoa_layout_pointer();
  }

  /**
  * Check whether or not the type is a dynamic pointer type.
  *
  * @return True if the type is a dynamic pointer type otherwise false.
  */
  internal func is_dynamic_pointer() -> bool {
    return self.kind == .Dynamic_Pointer;
  }

  /**
  * Check whether or not the type is a constant type.
  *
  * @return True if the type is a constant type otherwise false.
  */
  internal func is_constant() -> bool {
    return self.kind == .Constant;
  }

  /**
  * Check whether or not the type is an array type.
  *
  * @return True if the type is an array type otherwise false.
  */
  internal func is_array() -> bool {
    return self.kind == .Array;
  }

  /**
  * Check whether or not the type is an array type and incomplete.
  *
  * @return True if the type is an array type and incomplete otherwise false.
  */
  internal func is_array_and_incomplete() -> bool {
    return self.is_array() && (cast(*Type_Array) self).has_incomplete_elements;
  }

  /**
  * Check whether or not the type is an array type with SoA layout.
  *
  * @return True if the type is an array type with SoA layout otherwise false.
  */
  internal func is_array_soa() -> bool {
    return self.is_array() && (cast(*Type_Array) self).layout_info.modifier == .SoA;
  }

  /**
  * Check whether or not the type is an array type with AoSoA layout.
  *
  * @return True if the type is an array type with AoSoA layout otherwise false.
  */
  internal func is_array_aosoa() -> bool {
    return self.is_array() && (cast(*Type_Array) self).layout_info.modifier == .AoSoA;
  }

  /**
  * Check whether or not the type is an array type with SoA or AosoA layout.
  *
  * @return True if the type is an array type with SoA or AosoA layout otherwise false.
  */
  internal func is_array_soa_or_aosoa() -> bool {
    return self.is_array() && (cast(*Type_Array) self).layout_info.modifier != .None;
  }

  /**
  * Check whether or not the type is the a dynamic array type.
  *
  * @return True if the type is the a dynamic array type otherwise false.
  */
  internal func is_dynamic_array() -> bool {
    return self.kind == .Dynamic_Array;
  }

  /**
  * Check whether or not the type is the a dynamic array type with SoA layout.
  *
  * @return True if the type is the a dynamic array type with SoA layout otherwise false.
  */
  internal func is_dynamic_array_soa() -> bool {
    return self.is_dynamic_array() && (cast(*Type_Dynamic_Array) self).layout_info.modifier == .SoA;
  }

  /**
  * Check whether or not the type is the a dynamic array type with AoSoA layout.
  *
  * @return True if the type is the a dynamic array type with AoSoA layout otherwise false.
  */
  internal func is_dynamic_array_aosoa() -> bool {
    return self.is_dynamic_array() && (cast(*Type_Dynamic_Array) self).layout_info.modifier == .AoSoA;
  }

  /**
  * Check whether or not the type is the a dynamic array type with SoA or AoSoA layout.
  *
  * @return True if the type is the a dynamic array type with SoA or AoSoA layout otherwise false.
  */
  internal func is_dynamic_array_soa_or_aosoa() -> bool {
    return self.is_dynamic_array() && (cast(*Type_Dynamic_Array) self).layout_info.modifier != .None;
  }

  /**
  * Check whether or not the type is the a slice type.
  *
  * @return True if the type is the a slice type otherwise false.
  */
  internal func is_slice() -> bool {
    return self.kind == .Slice;
  }

  /**
  * Check whether or not the type is the a slice type with SoA layout.
  *
  * @return True if the type is the a slice type with SoA layout otherwise false.
  */
  internal func is_slice_soa() -> bool {
    return self.is_slice() && (cast(*Type_Slice) self).layout_info.modifier == .SoA;
  }

  /**
  * Check whether or not the type is the a slice type with AoSoA layout.
  *
  * @return True if the type is the a slice type with AoSoA layout otherwise false.
  */
  internal func is_slice_aosoa() -> bool {
    return self.is_slice() && (cast(*Type_Slice) self).layout_info.modifier == .AoSoA;
  }

  /**
  * Check whether or not the type is the a slice type with SoA or AoSoA layout.
  *
  * @return True if the type is the a slice type with SoA or AoSoA layout otherwise false.
  */
  internal func is_slice_soa_or_aosoa() -> bool {
    return self.is_slice() && (cast(*Type_Slice) self).layout_info.modifier != .None;
  }

  /**
  * Check whether or not the type is an SoA collection.
  * 
  * @return True if the type is an SoA collection otherwise false.
  */
  internal func is_soa() -> bool {
    return self.is_array_soa() || self.is_dynamic_array_soa() || self.is_slice_soa();
  }

  /**
  * Check whether or not the type is an AoSoA collection.
  *
  * @return True if the type is an AoSoA collection otherwise false.
  */
  internal func is_aosoa() -> bool {
    return self.is_array_aosoa() || self.is_dynamic_array_aosoa() || self.is_slice_aosoa();
  }

  /**
  * Check whether or not the type is an SoA or AoSoA collection.
  *
  * @return True if the type is an SoA or AoSoA collection otherwise false.
  */
  internal func is_soa_or_aosoa() -> bool {
    return self.is_array_soa_or_aosoa() || self.is_dynamic_array_soa_or_aosoa() || self.is_slice_soa_or_aosoa();
  }

  /**
  * Check whether or not the type is a map type.
  *
  * @return True if the type is a map type otherwise false.
  */
  internal func is_map() -> bool {
    return self.kind == .Map;
  }

  /**
  * Check whether or not the type is a tuple type.
  *
  * @return True if the type is a tuple type otherwise false.
  */
  internal func is_tuple() -> bool {
    return self.kind == .Tuple;
  }

  /**
  * Check whether or not the type is a struct type.
  *
  * @return True if the type is a struct type otherwise false.
  */
  internal func is_struct() -> bool {
    return self.kind == .Struct;
  }

  /**
  * Check whether or not the type is a union type.
  *
  * @return True if the type is a union type otherwise false.
  */
  internal func is_union() -> bool {
    return self.kind == .Union;
  }

  /**
  * Check whether or not the type is a procedure type.
  *
  * @return True if the type is a procedure type otherwise false.
  */
  internal func is_procedure() -> bool {
    return self.kind == .Procedure;
  }

  /**
  * Check whether or not the type is a function type.
  *
  * @return True if the type is a function type otherwise false.
  */
  internal func is_function() -> bool {
    return self.kind == .Function;
  }

  /**
  * Check whether or not the type is a routine type.
  *
  * @return True if the type is a routine type otherwise false.
  */
  internal func is_routine() -> bool {
    return self.is_procedure() || self.is_function();
  }

  /**
  * Check whether or not the type is an intrinsic routine type.
  *
  * @return True if the type is an intrinsic routine type otherwise false.
  */
  internal func is_routine_intrinsic() -> bool {
    return self.is_routine() && has_flag((cast(*Type_Routine) self).routine_flags, .Is_Intrinsic);
  }

  /**
  * Check whether or not the type is an interface type.
  *
  * @return True if the type is an interface type otherwise false.
  */
  internal func is_interface() -> bool {
    return self.kind == .Interface;
  }

  /**
  * Check whether or not the type is the any type.
  *
  * @return True if the type is the any type otherwise false.
  */
  internal func is_any() -> bool {
    return self.kind == .Any;
  }

  /**
  * Check whether or not the type is a tuple type.
  *
  * @return True if the type is a tuple type otherwise false.
  */
  internal func is_typeid() -> bool {
    return self.kind == .Typeid;
  }

  /**
  * Check whether or not the type is an untyped boolean type.
  *
  * @return True if the type is an untyped boolean type otherwise false.
  */
  internal func is_untyped_boolean() -> bool {
    return self.kind == .Untyped_Boolean;
  }

  /**
  * Check whether or not the type is an untyped integer type.
  * 
  * @return True if the type is an untyped integer type otherwise false.
  */
  internal func is_untyped_integer() -> bool {
    return self.kind == .Untyped_Integer;
  }

  /**
  * Check whether or not the type is an untyped float type.
  *
  * @return True if the type is an untyped float type otherwise false.
  */
  internal func is_untyped_float() -> bool {
    return self.kind == .Untyped_Float;
  }

  /**
  * Check whether or not the type is an untyped char type.
  *
  * @return True if the type is an untyped char type otherwise false.
  */
  internal func is_untyped_char() -> bool {
    return self.kind == .Untyped_Char;
  }

  /**
  * Check whether or not the type is an untyped string type.
  *
  * @return True if the type is an untyped string type otherwise false.
  */
  internal func is_untyped_string() -> bool {
    return self.kind == .Untyped_String;
  }

  /**
  * Check whether or not the type is an untyped null type.
  *
  * @return True if the type is an untyped null type otherwise false.
  */
  internal func is_untyped_null() -> bool {
    return self.kind == .Untyped_Null;
  }

  /**
  * Check whether or not the type is an untyped type.
  *
  * @return True if the type is an untyped type otherwise false.
  */
  internal func is_untyped() -> bool {
    return self.is_untyped_boolean()
      || self.is_untyped_integer()
      || self.is_untyped_float()
      || self.is_untyped_char()
      || self.is_untyped_string()
      || self.is_untyped_null();
  }

  /**
  * Check whether or not the type is a generic type.
  *
  * @return True if the type is a generic type otherwise false.
  */
  internal func is_generic() -> bool {
    return self.kind == .Generic;
  }

  /**
  * Check if the type constains a self-relative pointer in its value.
  * 
  * @param type The type to check.
  * @return True if the type constains a self-relative pointer in its value otherwise false.
  */
  internal func contains_self_relative_pointer_in_value() -> bool {
    return has_flag(self.flags, .Contains_Self_Relative_Pointer_In_Value);
  }

  /**
  * Gets the index of a struct field.
  * 
  * @param name The name of the field to get the index of.
  * @return The index of the struct field or -1 if not found.
  */
  internal proc get_struct_field_index(name: string) -> int {
    assert(self.is_struct());

    type_struct := cast(*Type_Struct) self;
    foreach (field, i in type_struct.fields) {
      if (field.name == name) then return i;
    }

    return -1;
  }

}

implement Type_Routine {

  /**
  * Check if a routine has an implicit context parameter.
  * 
  * @return True if the routine has an implicit context parameter otherwise false.
  */
  internal func has_context() -> bool {
    return self.calling_convention == .Nox && !has_flag(self.routine_flags, .Is_Pure_Function);
  }

}

/**
* Represents a cached constant type.
*/
internal struct Type_Cached_Constant {
  base: *Type,                     // The base type of the constant type.
  is_uninstantiated_generic: bool, // Is the type an uninstantied generic?
}

/**
* Represents a cached pointer type.
*/
internal struct Type_Cached_Pointer {
  base: *Type,                     // The base type of the pointer type.
  is_uninstantiated_generic: bool, // Is the type an uninstantied generic?
}

/**
* Represents a cached relative pointer type.
*/
internal struct Type_Cached_Relative_Pointer {
  base: *Type,                     // The base type of the relative pointer type.
  relative_base: *Type,            // The relative base of the relative pointer type.
  is_uninstantiated_generic: bool, // Is the type an uninstantied generic?
}

/**
* Represents a cached dynamic pointer type.
*/
internal struct Type_Cached_Dynamic_Pointer {
  base: *Type,                     // The base type of the dynamic pointer type.
  is_uninstantiated_generic: bool, // Is the type an uninstantied generic?
}

/**
* Represents a cached array type.
*/
internal struct Type_Cached_Array {
  layout_modifier: Layout_Modifier, // The layout modifier of the array type.
  base: *Type,                      // The base type of the array type.
  number_of_elements: int,          // The number of elements of the array.
  is_uninstantiated_generic: bool,  // Is the type an uninstantied generic?
}

/**
* Represents a cached dynamic array type.
*/
internal struct Type_Cached_Dynamic_Array {
  layout_modifier: Layout_Modifier, // The layout modifier of the dynamic array type.
  base: *Type,                      // The base type of the dynamic array type.
  is_uninstantiated_generic: bool,  // Is the type an uninstantied generic?
}

/**
* Represents a cached slice type.
*/
internal struct Type_Cached_Slice {
  layout_modifier: Layout_Modifier, // The layout modifier of the slice type.
  base: *Type,                      // The base type of the slice type.
  is_uninstantiated_generic: bool,  // Is the type an uninstantied generic?
}

/**
* Represents a cached map type.
*/
internal struct Type_Cached_Map {
  key: *Type,                      // The key type of the map type.
  value: *Type,                    // The value type of the map type.
  is_uninstantiated_generic: bool, // Is the type an uninstantied generic?
}

/**
* Represents a cached tuple type.
*/
internal struct Type_Cached_Tuple {
  elements: aosoa[dynamic]Type_Tuple_Element, // The elements of the tuple type.
  is_uninstantiated_generic: bool,            // Is the type an uninstantied generic?

  tuple: *Type,                               // The cached tuple type.
}

/**
* Represents a cached routine type.
*/
internal struct Type_Cached_Routine {
  calling_convention: Calling_Convention,           // The calling convention of the routine type.
  parameters: aosoa[dynamic]Type_Routine_Parameter, // The parameters of the routine type.
  return_type: *Type,                               // The return type of the routine type.
  routine_flags: Type_Routine_Flags,                // The flags of the routine type.
  is_uninstantiated_generic: bool,                  // Is the type an uninstantied generic?

  routine: *Type,                                   // The cached routine type.
}

/**
* Represents a cached generic type.
*/
internal struct Type_Cached_Generic {
  name: string, // The name of the generic type.
}

/**
* Represents a cached instantied type.
*/
internal struct Type_Cached_Instantiated {
  generic_types: [dynamic]*Type, // The generic types of the instantiated type.

  instantiated_type: *Type,      // The cached instantiated type.
}

/**
* Represents a cached layout struct type.
*/
internal struct Type_Cached_Layout_Struct {
  collection_type: Collection_Type, // The collection type the layout struct is used in.
  base_struct: *Type,               // The struct (in AoS form) the layout struct is based on.
  // For now we don't have the full 'Layout_Info' here as it is not needed.
  // The 'number_of_items_in_aosoa_chunk' is constant based on 'base_struct' and 'number_of_items'.
  layout_modifier: Layout_Modifier, // The layout modifier of the layout struct.
  number_of_elements: int,          // The number of elements (In case of a fixed array collection).
}

/**
* The cache for all types.
*/
internal struct Type_Cache {
  constants: map[Type_Cached_Constant]*Type,                        // Cached constant types.
  pointers: map[Type_Cached_Pointer]*Type,                          // Cached pointer types.
  self_relative_pointers: map[Type_Cached_Relative_Pointer]*Type,   // Cached self-relative pointer types.
  offset_relative_pointers: map[Type_Cached_Relative_Pointer]*Type, // Cached offset-relative pointer types.
  soa_layout_pointers: map[Type_Cached_Pointer]*Type,               // Cached SoA layout pointers.
  aosoa_layout_pointers: map[Type_Cached_Pointer]*Type,             // Cached AoSoA layout pointers.
  dynamic_pointers: map[Type_Cached_Dynamic_Pointer]*Type,          // Cached dynamic pointer types.
  arrays: map[Type_Cached_Array]*Type,                              // Cached array types.
  dynamic_arrays: map[Type_Cached_Dynamic_Array]*Type,              // Cached dynamic array types.
  slices: map[Type_Cached_Slice]*Type,                              // Cached slice types.
  maps: map[Type_Cached_Map]*Type,                                  // Cached map types.
  generics: map[Type_Cached_Generic]*Type,                          // Cached generic types.
  layout_structs: map[Type_Cached_Layout_Struct]*Type,              // Cached layout structs.

  // The following can't be maps as the cached structs contain a dynamic array which forbids being used as a map key.
  tuples: [dynamic]Type_Cached_Tuple,                               // Cached tuple types.
  procedures: [dynamic]Type_Cached_Routine,                         // Cached procedure type.
  functions: [dynamic]Type_Cached_Routine,                          // Cached function types.
  instantiated: map[*Type][dynamic]Type_Cached_Instantiated,        // Cached instantied type.
}

/**
* Cached types of the 'runtime' package.
*/
internal struct Type_Cached_Runtime_Types {
  operating_system_kind: *Type,      // The 'Operating_System_Kind' enum.
  source_location: *Type,            // The 'Source_Location' struct.
  context_struct: *Type,             // The 'Context' struct.
  allocator: *Type,                  // The 'Allocator' struct.

  type_info: *Type,                  // The 'Type_Info' struct.
  type_info_variant: *Type,          // The 'Type_Info_Variant' union.
  type_info_integer: *Type,          // The 'Type_Info_Integer' struct.
  type_info_enumeration: *Type,      // The 'Type_Info_Enumeration' struct.
  type_info_string: *Type,           // The 'Type_Info_String' struct.
  type_info_pointer: *Type,          // The 'Type_Info_Pointer' struct.
  type_info_relative_pointer: *Type, // The 'Type_Info_Relative_Pointer' struct.
  type_info_layout_pointer: *Type,   // The 'Type_Info_Layout_Pointer' struct.
  type_info_dynamic_pointer: *Type,  // The 'Type_Info_Dynamic_Pointer' struct.
  type_info_array: *Type,            // The 'Type_Info_Array' struct.
  type_info_dynamic_array: *Type,    // The 'Type_Info_Dynamic_Array' struct.
  type_info_slice: *Type,            // The 'Type_Info_Slice' struct.
  type_info_map: *Type,              // The 'Type_Info_Map' struct.
  type_info_tuple: *Type,            // The 'Type_Info_Tuple' struct.
  type_info_struct: *Type,           // The 'Type_Info_Struct' struct.
  type_info_union: *Type,            // The 'Type_Info_Union' struct.
  type_info_routine: *Type,          // The 'Type_Info_Routine' struct.
  type_info_interface: *Type,        // The 'Type_Info_Interface' struct.
}

/**
* Represents all stored types in a program.
*/
internal struct Type_Storage {
  types: [dynamic]*Type,                           // Holds all allocated types.
  typeid_counter: Type_Id,                         // The type id counter.
  
  type_pool: memory.Pool,                          // The backing pool for the type allocator.
  type_allocator: Allocator,                       // The allocator used for types.

  name_pool: memory.Pool,                          // The backing pool for the name allocator.
  name_allocator: Allocator,                       // The allocator used for type names.

  type_void: *Type,                                // The 'void' type.
  type_b8: *Type,                                  // The 'b8' type.
  type_b16: *Type,                                 // The 'b16' type.
  type_b32: *Type,                                 // The 'b32' type.
  type_b64: *Type,                                 // The 'b64' type.
  type_bool: *Type,                                // The 'bool' type.
  type_i8: *Type,                                  // The 'i8' type.
  type_i16: *Type,                                 // The 'i16' type.
  type_i32: *Type,                                 // The 'i32' type.
  type_i64: *Type,                                 // The 'i64' type.
  type_int: *Type,                                 // The 'int' type.
  type_u8: *Type,                                  // The 'u8' type.
  type_u16: *Type,                                 // The 'u16' type.
  type_u32: *Type,                                 // The 'u32' type.
  type_u64: *Type,                                 // The 'u64' type.
  type_uint: *Type,                                // The 'uint' type.
  type_f32: *Type,                                 // The 'f32' type.
  type_f64: *Type,                                 // The 'f64' type.
  type_char: *Type,                                // The 'char' type.
  type_string: *Type,                              // The 'string' type.
  type_cstring: *Type,                             // The 'cstring' type.
  type_rawptr: *Type,                              // The 'rawptr' type.
  type_any: *Type,                                 // The 'any' type.
  type_typeid: *Type,                              // The 'typeid' type.
  type_untyped_boolean: *Type,                     // The untyped 'boolean' type.
  type_untyped_integer: *Type,                     // The untyped 'integer' type.
  type_untyped_float: *Type,                       // The untyped 'float' type.
  type_untyped_char: *Type,                        // The untyped 'char' type.
  type_untyped_string: *Type,                      // The untyped 'string' type.
  type_untyped_null: *Type,                        // The untyped 'null' type.

  cache: Type_Cache,                               // All cached types in the storage.
  cached_runtime_types: Type_Cached_Runtime_Types, // The cached types in the 'runtime' package.
}

/**
* Represents the metric for a built-in type.
*/
internal struct Type_Metric {
  size: uint,      // The size of the type in bytes.
  alignment: uint, // The alignment of the type in bytes.
  unsigned: bool,  // Is the type unsigned? (Only applicable for integers)
}

/**
* Holds the type metrics for all built-in types.
* (NOTE: This is only for 64-bit architectures as this is the only one we support.)
*/
internal global TYPE_METRICS: [64]Type_Metric = {
  [Type_Kind.B8]                    = {1, 1, true},
  [Type_Kind.B16]                   = {2, 2, true},
  [Type_Kind.B32]                   = {4, 4, true},
  [Type_Kind.B64]                   = {8, 8, true},
  [Type_Kind.Bool]                  = {1, 1, true},
  
  [Type_Kind.I8]                    = {1, 1, false},
  [Type_Kind.I16]                   = {2, 2, false},
  [Type_Kind.I32]                   = {4, 4, false},
  [Type_Kind.I64]                   = {8, 8, false},
  [Type_Kind.Int]                   = {8, 8, false},
  [Type_Kind.U8]                    = {1, 1, true},
  [Type_Kind.U16]                   = {2, 2, true},
  [Type_Kind.U32]                   = {4, 4, true},
  [Type_Kind.U64]                   = {8, 8, true},
  [Type_Kind.UInt]                  = {8, 8, true},
  
  [Type_Kind.F32]                   = {4, 4, false},
  [Type_Kind.F64]                   = {8, 8, false},

  [Type_Kind.Char]                  = {4, 4, true},

  [Type_Kind.String]                = {16, 8, false}, // Internal structure: (rawptr, int).
  [Type_Kind.CString]               = {8, 8, true},

  [Type_Kind.Rawptr]                = {8, 8, true},
  [Type_Kind.Pointer]               = {8, 8, true},
  [Type_Kind.SoA_Layout_Pointer]    = {16, 8, false}, // Internal structure: (rawptr, int).
  [Type_Kind.AoSoA_Layout_Pointer]  = {16, 8, false}, // Internal structure: (rawptr, int).
  [Type_Kind.Dynamic_Pointer]       = {16, 8, false}, // Internal structure: (rawptr, rawptr).

  [Type_Kind.Dynamic_Array]         = {40, 8, false}, // Internal structure: (rawptr, int, int, Allocator).
  [Type_Kind.Slice]                 = {16, 8, false}, // Internal structure: (rawptr, int).
  [Type_Kind.Map]                   = {56, 8, false}, // Internal structure: (rawptr, int, int, Allocator, rawptr, rawptr).

  [Type_Kind.Any]                   = {16, 8, false}, // Internal structure: (rawptr, int).
  [Type_Kind.Typeid]                = {8, 8, false},
};

/**
* Makes a new type storage.
*
* @return The new type storage.
*/
internal proc type_storage_make() -> *Type_Storage {
  storage := memory.new!(Type_Storage)();
  storage.init();
  return storage;
}

/**
* Destroys the resources associated with a type storage.
*
* @param storage The type storage to destroy.
*/
internal proc type_storage_destroy(storage: *Type_Storage) {
  foreach (type in storage.types) {
    if (type.is_enumeration()) {
      array_aosoa_destroy(&(cast(*Type_Enumeration) type).items);
    } else if (type.is_struct()) {
      type_struct := cast(*Type_Struct) type;
      array_aosoa_destroy(&type_struct.fields);
      array_destroy(&type_struct.generic_types);
    } else if (type.is_union()) {
      array_destroy(&(cast(*Type_Union) type).variants);
    } else if (type.is_tuple()) {
      array_aosoa_destroy(&(cast(*Type_Tuple) type).elements);
    } else if (type.is_routine()) {
      array_aosoa_destroy(&(cast(*Type_Routine) type).parameters);
    }

    array_aosoa_destroy(&type.methods);
    array_destroy(&type.interfaces);
  }
  array_destroy(&storage.types);

  memory.pool_destroy(&storage.type_pool);
  memory.pool_destroy(&storage.name_pool);

  map_destroy(&storage.cache.constants);
  map_destroy(&storage.cache.constants);
  map_destroy(&storage.cache.pointers);
  map_destroy(&storage.cache.self_relative_pointers);
  map_destroy(&storage.cache.offset_relative_pointers);
  map_destroy(&storage.cache.soa_layout_pointers);
  map_destroy(&storage.cache.aosoa_layout_pointers);
  map_destroy(&storage.cache.dynamic_pointers);
  map_destroy(&storage.cache.arrays);
  map_destroy(&storage.cache.dynamic_arrays);
  map_destroy(&storage.cache.slices);
  map_destroy(&storage.cache.maps);
  array_destroy(&storage.cache.tuples);
  map_destroy(&storage.cache.generics);
  array_destroy(&storage.cache.procedures);
  array_destroy(&storage.cache.functions);
  foreach (_, cached_types_instantiated in storage.cache.instantiated) {
    cached_types_instantiated_local := cached_types_instantiated;
    array_destroy(&cached_types_instantiated_local);
  }
  map_destroy(&storage.cache.instantiated);
  map_destroy(&storage.cache.layout_structs);

  memory.free(storage);
}

implement Type_Storage {

  /**
  * Initializes a type storage.
  */
  internal proc init() {
    L1_CACHE_LINE_SIZE = system.get_l1_cache_line_size();

    // We start the counter at 1, so that 0 can denote an invalid id.
    self.typeid_counter = 1;

    memory.pool_init(&self.type_pool);
    self.type_allocator = memory.pool_allocator(&self.type_pool);

    memory.pool_init(&self.name_pool);
    self.name_allocator = memory.pool_allocator(&self.name_pool);

    void_flags := Type_Flags.Not_Allowed_As_Base |
    Type_Flags.Not_Allowed_As_Parameter_Or_Return_Type |
    Type_Flags.Not_Allowed_As_Variable |
    Type_Flags.Not_Allowed_As_Field |
    Type_Flags.Not_Allowed_As_Tuple |
    Type_Flags.Not_Allowed_As_Union |
    Type_Flags.Not_Allowed_As_Parameter_In_Pure_Function;
    common_flags := Type_Flags.Has_Hash_Function | Type_Flags.Has_Compare_Function;
    string_flags := common_flags | .Passed_As_Pointer;
    any_flags := common_flags | .Passed_As_Pointer | .Requires_Address_Load;
    self.init_builtin_type(&self.type_void, .Void, "void", void_flags);
    self.init_builtin_type(&self.type_b8, .B8, "b8", common_flags);
    self.init_builtin_type(&self.type_b16, .B16, "b16", common_flags);
    self.init_builtin_type(&self.type_b32, .B32, "b32", common_flags);
    self.init_builtin_type(&self.type_b64, .B64, "b64", common_flags);
    self.init_builtin_type(&self.type_bool, .Bool, "bool", common_flags);
    self.init_builtin_type(&self.type_i8, .I8, "i8", common_flags);
    self.init_builtin_type(&self.type_i16, .I16, "i16", common_flags);
    self.init_builtin_type(&self.type_i32, .I32, "i32", common_flags);
    self.init_builtin_type(&self.type_i64, .I64, "i64", common_flags);
    self.init_builtin_type(&self.type_int, .Int, "int", common_flags);
    self.init_builtin_type(&self.type_u8, .U8, "u8", common_flags);
    self.init_builtin_type(&self.type_u16, .U16, "u16", common_flags);
    self.init_builtin_type(&self.type_u32, .U32, "u32", common_flags);
    self.init_builtin_type(&self.type_u64, .U64, "u64", common_flags);
    self.init_builtin_type(&self.type_uint, .UInt, "uint", common_flags);
    self.init_builtin_type(&self.type_f32, .F32, "f32", common_flags);
    self.init_builtin_type(&self.type_f64, .F64, "f64", common_flags);
    self.init_builtin_type(&self.type_char, .Char, "char", common_flags);
    self.init_builtin_type(&self.type_string, .String, "string", string_flags);
    self.init_builtin_type(&self.type_cstring, .CString, "cstring", common_flags);
    self.init_builtin_type(&self.type_rawptr, .Rawptr, "rawptr", common_flags);
    self.init_builtin_type(&self.type_any, .Any, "any", any_flags);
    self.init_builtin_type(&self.type_typeid, .Typeid, "typeid", common_flags);
    self.init_builtin_type(&self.type_untyped_boolean, .Untyped_Boolean, "untyped boolean");
    self.init_builtin_type(&self.type_untyped_integer, .Untyped_Integer, "untyped integer");
    self.init_builtin_type(&self.type_untyped_float, .Untyped_Float, "untyped float");
    self.init_builtin_type(&self.type_untyped_char, .Untyped_Char, "untyped char");
    self.init_builtin_type(&self.type_untyped_string, .Untyped_String, "untyped string");
    self.init_builtin_type(&self.type_untyped_null, .Untyped_Null, "untyped null");

    self.type_rawptr.base = self.type_void;
  }

  /**
  * Initializes a built-in type.
  *
  * @param out_type Pointer to the type that will be set as the built-in type.
  * @param kind     The kind of the built-in type.
  * @param name     The name of the built-in type.
  * @param flags    The flags of the built-in type.
  */
  private proc init_builtin_type(out_type: **Type, kind: Type_Kind, name: string, flags: Type_Flags = {}) {
    type := self.make_type!(Type)(kind, name);
    type.flags = flags;
    type.size = TYPE_METRICS[kind].size;
    type.alignment = TYPE_METRICS[kind].alignment;
    // We will always generate RTTR for basic types (which are not untyped).
    if (!type.is_untyped()) then set_flag(&type.flags, .Generate_RTTR);
    *out_type = type;
  }

  /**
  * Makes a new type.
  *
  * @param T    The type of the type to make.
  * @param kind The kind of the type to make.
  * @param name The name of the type to make.
  * @return The new type.
  */
  internal proc make_type!(T)(kind: Type_Kind, name: string) -> *T {
    type := memory.new!(T)(self.type_allocator);
    type.id = self.typeid_counter;
    type.kind = kind;
    type.state = .Completed;
    type.name = name;

    self.typeid_counter++;
    array_add(&self.types, cast(*Type) type);

    return type;
  }

  /**
  * Copies relevant data from a source type to a destination type.
  * 
  * @param T                The type of the destination type.
  * @param destination_type The destination type.
  * @param source_type      The source type.
  */
  internal proc copy_type!(T)(destination_type: *T, source_type: *Type) {
    id := destination_type.id;
    name := destination_type.name;
    *destination_type = *cast(*T) source_type;
    destination_type.id = id;
    destination_type.name = name;
    destination_type.methods = {}; // The methods a type implements are unique for any given type (even instantiated structs).
  }

  /**
  * Makes a new incomplete type (Can only ever be a struct or union).
  *
  * @param kind   The kind of the incomplete type.
  * @param symbol The symbol that defines the incomplete type.
  * @return The new incomplete type.
  */
  internal proc make_type_incomplete(kind: Type_Kind, symbol: *Symbol) -> *Type {
    assert(kind == .Struct || kind == .Union);

    type: *Type;
    if (kind == .Struct) {
      type = cast(*Type) self.make_type!(Type_Struct)(kind, symbol.name);
    } else if (kind == .Union) {
      type = cast(*Type) self.make_type!(Type_Union)(kind, symbol.name);
    } else {
      assert(false);
    }
    
    if (has_flag(symbol.flags, .Uninstantiated_Generic)) then set_flag(&type.flags, .Uninstantiated_Generic);
    type.state = .Incomplete;
    type.symbol = symbol;

    return type;
  }

  /**
  * Makes a new distinct type.
  *
  * @param name The name of the distinct type.
  * @param base The base type of the distinct type.
  * @return The new distinct type.
  */
  internal proc make_type_distinct(name: string, base: *Type) -> *Type {
    kind := base.kind;
    switch (kind) {
      case .Enumeration:             return self.make_type_distinct_internal!(Type_Enumeration)(kind, name, base);
      case .Self_Relative_Pointer:   return self.make_type_distinct_internal!(Type_Relative_Pointer)(kind, name, base);
      case .Offset_Relative_Pointer: return self.make_type_distinct_internal!(Type_Relative_Pointer)(kind, name, base);
      case .Array:                   return self.make_type_distinct_internal!(Type_Array)(kind, name, base);
      case .Dynamic_Array:           return self.make_type_distinct_internal!(Type_Dynamic_Array)(kind, name, base);
      case .Slice:                   return self.make_type_distinct_internal!(Type_Slice)(kind, name, base);
      case .Map:                     return self.make_type_distinct_internal!(Type_Map)(kind, name, base);
      case .Tuple:                   return self.make_type_distinct_internal!(Type_Tuple)(kind, name, base);
      case .Struct:                  return self.make_type_distinct_internal!(Type_Struct)(kind, name, base);
      case .Union:                   return self.make_type_distinct_internal!(Type_Union)(kind, name, base);
      case .Procedure, .Function:    return self.make_type_distinct_internal!(Type_Routine)(kind, name, base);
      case:                          return self.make_type_distinct_internal!(Type)(kind, name, base);
    }
  }

  /**
  * Makes a new distinct type from a concrete provided type.
  *
  * @param T    The type of the distinct type.
  * @param kind The kind of the distinct type.
  * @param name The name of the distinct type.
  * @param base The base type of the distinct type.
  * @return The new distinct type.
  */
  private proc make_type_distinct_internal!(T)(kind: Type_Kind, name: string, base: *Type) -> *Type {
    type := self.make_type!(T)(kind, name);
    self.copy_type(type, base);
    set_flag(&type.flags, .Defined_Distinct);
    return cast(*Type) type;
  }

  /**
  * Makes a new enumeration type.
  *
  * @param symbol   The symbol that defines the enumeration type.
  * @param base     The base type of the enumeration type.
  * @param items    The items of the enumeration type.
  * @param is_flags Is the enumeratioon type marked with the '@flags' attribute?
  * @return The new enumeration type.
  */
  internal proc make_type_enumeration(symbol: *Symbol, base: *Type, items: aosoa[dynamic]Type_Enumeration_Item, is_flags: bool) -> *Type {
    type := self.make_type!(Type_Enumeration)(.Enumeration, symbol.name);
    type.symbol = symbol;
    type.size = base.get_size();
    type.alignment = base.get_alignment();
    type.base = base;
    type.items = items;
    type.is_flags = is_flags;
    set_flag(&type.flags, .Has_Hash_Function);
    set_flag(&type.flags, .Has_Compare_Function);
    return cast(*Type) type;
  }

  /**
  * Makes a new routine type.
  *
  * @param kind               The kind of the routine type.
  * @param calling_convention The calling convention of the routine type.
  * @param parmaters          The parameters of the routine type.
  * @param return_type        The return type of the routine type.
  * @param flags              Is the enumeratioon type marked with the '@flags' attribute?
  * @return The new routine type.
  */
  internal proc make_type_routine(
    kind: Type_Kind,
    calling_convention: Calling_Convention,
    parameters: aosoa[dynamic]Type_Routine_Parameter,
    return_type: *Type,
    routine_flags: Type_Routine_Flags,
  ) -> *Type {
    assert(kind == .Procedure || kind == .Function);

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_routine_raw(kind, calling_convention, parameters, return_type, routine_flags, "");
    name := name_builder.to_string();

    type := self.make_type!(Type_Routine)(kind, name);
    type.size = TYPE_METRICS[Type_Kind.Pointer].size;
    type.alignment = TYPE_METRICS[Type_Kind.Pointer].alignment;
    type.calling_convention = calling_convention;
    type.parameters = parameters;
    type.return_type = return_type;
    type.routine_flags = routine_flags;

    foreach (parameter in parameters) {
      if (has_flag(parameter.type.flags, .Uninstantiated_Generic)) {
        set_flag(&type.flags, .Uninstantiated_Generic);
        break;
      }
    }
    if (has_flag(return_type.flags, .Uninstantiated_Generic)) then set_flag(&type.flags, .Uninstantiated_Generic);

    if (has_flag(routine_flags, .Is_Intrinsic) || has_flag(routine_flags, .Is_Method)) {
      set_flag(&type.flags, .Not_Allowed_As_Pointer);
      set_flag(&type.flags, .Not_Allowed_As_Base);
      set_flag(&type.flags, .Not_Allowed_As_Field);
      set_flag(&type.flags, .Not_Allowed_As_Union);
      set_flag(&type.flags, .Not_Allowed_As_Tuple);
      set_flag(&type.flags, .Not_Allowed_As_Parameter_Or_Return_Type);
    }

    return cast(*Type) type;
  }

  /**
  * Makes a new interface type.
  *
  * @param symbol  The symbol that defines the interface type.
  * @param methods The methods of the interface type.
  * @return The new interface type.
  */
  internal proc make_type_interface(symbol: *Symbol, methods: aosoa[dynamic]Type_Method) -> *Type {
    type := self.make_type!(Type)(.Interface, symbol.name);
    type.symbol = symbol;
    type.methods = methods;

    set_flag(&type.flags, .Not_Allowed_As_Pointer);
    set_flag(&type.flags, .Not_Allowed_As_Base);
    set_flag(&type.flags, .Not_Allowed_As_Field);
    set_flag(&type.flags, .Not_Allowed_As_Union);
    set_flag(&type.flags, .Not_Allowed_As_Tuple);
    set_flag(&type.flags, .Not_Allowed_As_Variable);
    set_flag(&type.flags, .Not_Allowed_As_Parameter_Or_Return_Type);

    return type;
  }

  /**
  * Makes a new instantiated type (Can only ever be a struct).
  *
  * @param uninstantiated_symbol The symbol that defines the uninstantiated type.
  * @param generic_types         The generic types of the instantiated type.
  * @return The new instantiated type.
  */
  internal proc make_type_instantiated(uninstantiated_symbol: *Symbol, generic_types: [dynamic]*Type) -> *Type {
    assert(uninstantiated_symbol.type.is_struct());

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_struct(uninstantiated_symbol.name, generic_types);
    name := name_builder.to_string();

    is_uninstantiated_generic := false;
    foreach (generic_type in generic_types) {
      if (has_flag(generic_type.flags, .Uninstantiated_Generic)) {
        is_uninstantiated_generic = true;
        break;
      }
    }

    type := self.make_type!(Type_Struct)(.Struct, name);
    self.copy_type(type, uninstantiated_symbol.type);
    if (is_uninstantiated_generic) {
      set_flag(&type.flags, .Uninstantiated_Generic);
    } else {
      remove_flag(&type.flags, .Uninstantiated_Generic);
    }
    type.fields = {};
    type.layout_info = {};
    type.generic_types = generic_types;

    chached_types_instantiated, _ := map_get(&self.cache.instantiated, uninstantiated_symbol.type);
    array_add(&chached_types_instantiated, {generic_types, cast(*Type) type});
    map_set(&self.cache.instantiated, uninstantiated_symbol.type, chached_types_instantiated);

    return cast(*Type) type;
  }

  /**
  * Makes a new layout struct type.
  *
  * @param symbol               The symbol that will represent the layout struct.
  * @param collection_type      The type of collection the layout struct will be used in.
  * @param base_struct          The base struct in AoS form that the layout struct is based on.
  * @param layout_modifier      The layout modifier of the layout struct.
  * @param number_of_elements   The number of elements (Only applicable for a fixed array collection).
  * @param aosoa_chunk_symbol   The AoSoA chunk symbol that will represent a single AoSoA chunk (Only applicable for an AoSoA layout).
  * @param items_in_aosoa_chunk The number of items in an AoSoA chunk (Only applicable for an AoSoA layout).
  * @return The new layout struct type.
  */
  internal proc make_type_layout_struct(
    symbol: *Symbol,
    collection_type: Collection_Type,
    base_struct: *Type,
    layout_modifier: Layout_Modifier,
    number_of_elements: int,
    aosoa_chunk_symbol: *Symbol,
    items_in_aosoa_chunk: int,
  ) -> *Type {
    assert(layout_modifier != .None);
    assert(base_struct.is_struct());

    type := self.make_type_incomplete(.Struct, symbol);
    type_struct := cast(*Type_Struct) base_struct;

    aosoa_array_chunk_type: *Type;
    if (layout_modifier == .AoSoA) {
      assert(items_in_aosoa_chunk > 0);

      // Example layout for 'aosoa[8]Foo':
      // struct Foo {
      //   i: int,
      //   s: string,
      // }
      // struct Array_AoSoA {
      //   base: [2]Array_AoSoA_Base,
      // }
      // struct Array_AoSoA_Base {
      //   i: int[4],
      //   s: int[4],
      // }

      base_fields: aosoa[dynamic]Type_Struct_Field;
      fields := type_struct.fields;
      foreach (field in fields) {
        base_field_array_type := self.get_or_make_type_array(SOA_INFO_NONE, field.type, items_in_aosoa_chunk, false);
        array_aosoa_add(&base_fields, {.Private, false, field.name, base_field_array_type, 0});
      }

      aosoa_array_chunk_type = self.make_type_incomplete(.Struct, aosoa_chunk_symbol);
      self.complete_type_struct(aosoa_array_chunk_type, base_fields, SOA_INFO_NONE);
      aosoa_array_chunk_type.state = .Completed;
      aosoa_chunk_symbol.type = aosoa_array_chunk_type;
    }

    fields: aosoa[dynamic]Type_Struct_Field;
    switch (collection_type) {
      case .Array: {
        // For an AoSoA array we have to fully layout the data beforehand.
        // To do that we need to figure out how many items we can find inside a single cache/SIMD chunk.
        // For now this is hardcoded to 64 bytes.
        if (layout_modifier == .AoSoA) {
          number_of_needed_arrays := (number_of_elements + (items_in_aosoa_chunk - 1)) / items_in_aosoa_chunk;
          field_array_type := self.get_or_make_type_array(SOA_INFO_NONE, aosoa_array_chunk_type, number_of_needed_arrays, false);
          array_aosoa_add(&fields, {.Private, false, "aosoa", field_array_type, 0});
        } else {
          foreach (field in type_struct.fields) {
            field_array_type := self.get_or_make_type_array(SOA_INFO_NONE, field.type, number_of_elements, false);
            array_aosoa_add(&fields, {.Private, false, field.name, field_array_type, 0});
          }
        }
      }
      case .Dynamic_Array, .Slice: {
        // For AoSoA we will just have a single data pointer and do all necessary pointer arithmetic inside the code generator.
        // The reason is that we don't have a way to properly divide the single data pointer into multiple.
        // At least not in the "simple" way in the case of SoA (a single data pointer for every field).
        if (layout_modifier == .AoSoA) {
          aosoa_data_pointer_type := self.get_or_make_type_pointer(aosoa_array_chunk_type);
          array_aosoa_add(&fields, {.Private, false, "data", aosoa_data_pointer_type, 0});
        } else {
          foreach (field in type_struct.fields) {
            field_array_type := self.get_or_make_type_pointer(field.type);
            array_aosoa_add(&fields, {.Private, false, field.name, field_array_type, 0});
          }
        }

        array_aosoa_add(&fields, {.Private, false, "length", self.type_int, 0});
        if (collection_type == .Dynamic_Array) {
          array_aosoa_add(&fields, {.Private, false, "capacity", self.type_int, 0});
          array_aosoa_add(&fields, {.Private, false, "allocator", self.cached_runtime_types.allocator, 0});
        }
      }
      case .None: fallthrough;
      case: assert(false);
    }

    // We link the 'normal' base struct to the layout struct. That way we can refer to it when needed.
    type.base = base_struct;

    layout_info := Layout_Info{layout_modifier, items_in_aosoa_chunk};
    self.complete_type_struct(type, fields, layout_info);
    type.state = .Completed;

    cached_layout_struct := Type_Cached_Layout_Struct{collection_type, base_struct, layout_modifier, number_of_elements};
    map_set(&self.cache.layout_structs, cached_layout_struct, type);

    return type;
  }

  /**
  * Gets a cached constant type or makes a new one.
  * 
  * @param base The base type of the constant.
  * @return The constant type.
  */
  internal proc get_or_make_type_constant(base: *Type) -> *Type {
    if (base.is_constant()) then return base;

    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);

    cached_constant := Type_Cached_Constant{base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.constants, cached_constant);
    if (found) then return cached_type;

    type := self.make_type!(Type)(.Constant, base.name);
    type.flags = base.flags;
    type.size = base.size;
    type.alignment = base.alignment;
    type.base = base;
    set_flag(&type.flags, .Non_Modifiable);
    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.constants, cached_constant, type);

    return type;
  }

  /**
  * Gets a cached pointer type or makes a new one.
  * 
  * @param base The base type of the pointer.
  * @return The pointer type.
  */
  internal proc get_or_make_type_pointer(base: *Type) -> *Type {
    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);

    cached_pointer := Type_Cached_Pointer{base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.pointers, cached_pointer);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_pointer(.Pointer, base, null);
    name := name_builder.to_string();

    type := self.make_type!(Type)(.Pointer, name);
    type.size = TYPE_METRICS[Type_Kind.Pointer].size;
    type.alignment = TYPE_METRICS[Type_Kind.Pointer].alignment;
    type.base = base;

    set_flag(&type.flags, .Not_Allowed_As_Parameter_In_Pure_Function);
    set_flag(&type.flags, .Has_Hash_Function);
    set_flag(&type.flags, .Has_Compare_Function);
    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.pointers, cached_pointer, type);

    return type;
  }

  /**
  * Gets a cached self-relative pointer type or makes a new one.
  * 
  * @param base          The base type of the self-relative pointer.
  * @param relative_base The relative base type of the self-relative pointer.
  * @return The self-relative pointer type.
  */
  internal proc get_or_make_type_self_relative_pointer(base: *Type, relative_base: *Type) -> *Type {
    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);

    cached_self_relative_pointer := Type_Cached_Relative_Pointer{base, relative_base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.self_relative_pointers, cached_self_relative_pointer);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_pointer(.Self_Relative_Pointer, base, relative_base);
    name := name_builder.to_string();

    type := self.make_type!(Type_Relative_Pointer)(.Self_Relative_Pointer, name);
    type.size = relative_base.get_size();
    type.alignment = relative_base.get_alignment();
    type.base = base;
    type.relative_base = relative_base;

    set_flag(&type.flags, .Not_Allowed_As_Union);
    set_flag(&type.flags, .Not_Allowed_As_Parameter_Or_Return_Type);
    set_flag(&type.flags, .Not_Allowed_As_Parameter_In_Pure_Function);
    set_flag(&type.flags, .Contains_Self_Relative_Pointer_In_Value);
    set_flag(&type.flags, .Requires_Address_Load);
    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.self_relative_pointers, cached_self_relative_pointer, cast(*Type) type);
    
    return cast(*Type) type;
  }

  /**
  * Gets a cached offset-relative pointer type or makes a new one.
  * 
  * @param base          The base type of the offset-relative pointer.
  * @param relative_base The relative base type of the offset-relative pointer.
  * @return The offset-relative pointer type.
  */
  internal proc get_or_make_type_offset_relative_pointer(base: *Type, relative_base: *Type) -> *Type {
    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);

    cached_offset_relative_pointer := Type_Cached_Relative_Pointer{base, relative_base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.offset_relative_pointers, cached_offset_relative_pointer);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_pointer(.Offset_Relative_Pointer, base, relative_base);
    name := name_builder.to_string();

    type := self.make_type!(Type_Relative_Pointer)(.Offset_Relative_Pointer, name);
    type.size = relative_base.get_size();
    type.alignment = relative_base.get_alignment();
    type.base = base;
    type.relative_base = relative_base;

    set_flag(&type.flags, .Has_Hash_Function);
    set_flag(&type.flags, .Has_Compare_Function);
    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.offset_relative_pointers, cached_offset_relative_pointer, cast(*Type) type);
    
    return cast(*Type) type;
  }

  /**
  * Gets a cached SoA pointer type or makes a new one.
  * 
  * @param base The base type of the SoA pointer.
  * @return The SoA pointer type.
  */
  internal proc get_or_make_type_soa_pointer(base: *Type) -> *Type {
    assert(base.is_soa());

    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);

    cached_pointer := Type_Cached_Pointer{base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.soa_layout_pointers, cached_pointer);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_pointer(.SoA_Layout_Pointer, base, null);
    name := name_builder.to_string();

    type := self.make_type!(Type)(.SoA_Layout_Pointer, name);
    type.size = TYPE_METRICS[Type_Kind.SoA_Layout_Pointer].size;
    type.alignment = TYPE_METRICS[Type_Kind.SoA_Layout_Pointer].alignment;
    type.base = base;

    set_flag(&type.flags, .Not_Allowed_As_Parameter_In_Pure_Function);
    set_flag(&type.flags, .Passed_As_Pointer);
    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.soa_layout_pointers, cached_pointer, type);

    return type;
  }

  /**
  * Gets a cached AoSoA pointer type or makes a new one.
  * 
  * @param base The base type of the AoSoA pointer.
  * @return The AoSoA pointer type.
  */
  internal proc get_or_make_type_aosoa_pointer(base: *Type) -> *Type {
    assert(base.is_aosoa());

    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);

    cached_pointer := Type_Cached_Pointer{base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.aosoa_layout_pointers, cached_pointer);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_pointer(.AoSoA_Layout_Pointer, base, null);
    name := name_builder.to_string();

    type := self.make_type!(Type)(.AoSoA_Layout_Pointer, name);
    type.size = TYPE_METRICS[Type_Kind.AoSoA_Layout_Pointer].size;
    type.alignment = TYPE_METRICS[Type_Kind.AoSoA_Layout_Pointer].alignment;
    type.base = base;

    set_flag(&type.flags, .Not_Allowed_As_Parameter_In_Pure_Function);
    set_flag(&type.flags, .Passed_As_Pointer);
    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.aosoa_layout_pointers, cached_pointer, type);

    return type;
  }

  /**
  * Gets a cached dynamic pointer type or makes a new one.
  * 
  * @param base The base type of the dynamic pointer.
  * @return The dynamic pointer type.
  */
  internal proc get_or_make_type_dynamic_pointer(base: *Type) -> *Type {
    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);

    cached_dynamic_pointer := Type_Cached_Dynamic_Pointer{base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.dynamic_pointers, cached_dynamic_pointer);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_pointer(.Dynamic_Pointer, base, null);
    name := name_builder.to_string();

    type := self.make_type!(Type)(.Dynamic_Pointer, name);
    type.size = TYPE_METRICS[Type_Kind.Dynamic_Pointer].size;
    type.alignment = TYPE_METRICS[Type_Kind.Dynamic_Pointer].alignment;
    type.base = base;

    set_flag(&type.flags, .Not_Allowed_As_Parameter_In_Pure_Function);
    set_flag(&type.flags, .Passed_As_Pointer);
    set_flag(&type.flags, .Has_Hash_Function);
    set_flag(&type.flags, .Has_Compare_Function);
    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    set_flag(&base.flags, .Interface_Used_In_Dynamic_Pointer);

    map_set(&self.cache.dynamic_pointers, cached_dynamic_pointer, type);
    
    return type;
  }

  /**
  * Gets a cached array type or makes a new one.
  * 
  * @param layout_info             The layout info of the array.
  * @param base                    The base type of the array.
  * @param number_of_elements      The number of items in the array.
  * @param has_incomplete_elements Is the array incomplete?
  * @return The array type.
  */
  internal proc get_or_make_type_array(layout_info: Layout_Info, base: *Type, number_of_elements: int, has_incomplete_elements: bool) -> *Type {
    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);
    layout_modifier := layout_info.modifier;

    cached_array := Type_Cached_Array{layout_modifier, base, number_of_elements, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.arrays, cached_array);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_array_or_slice(.Array, layout_modifier, base, number_of_elements, has_incomplete_elements);
    name := name_builder.to_string();

    type := self.make_type!(Type_Array)(.Array, name);
    // The size calculation depends on the number of elements we have.
    // If we are an soa array we also have to take account that our 'base' is an layout struct.
    // That means our actual base is the 'regular struct' stored in the layout struct as a base.
    size_base := layout_modifier == .None ? base : base.base;
    type.size = cast(uint) number_of_elements * size_base.get_size();
    type.alignment = size_base.get_alignment();
    type.base = base;
    type.layout_info = layout_info;
    type.number_of_elements = number_of_elements;
    type.has_incomplete_elements = has_incomplete_elements;

    set_flag(&type.flags, .Passed_As_Pointer);
    if (has_incomplete_elements) {
      set_flag(&type.flags, .Not_Allowed_As_Field);
      set_flag(&type.flags, .Not_Allowed_As_Union);
      set_flag(&type.flags, .Not_Allowed_As_Parameter_Or_Return_Type);
    }
    if (base.contains_self_relative_pointer_in_value()) {
      set_flag(&type.flags, .Not_Allowed_As_Union);
      set_flag(&type.flags, .Contains_Self_Relative_Pointer_In_Value);
      set_flag(&type.flags, .Requires_Address_Load);
    }
    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    if (!has_incomplete_elements) {
      map_set(&self.cache.arrays, cached_array, cast(*Type) type);
    }

    return cast(*Type) type;
  }

  /**
  * Gets a cached dynamic array type or makes a new one.
  * 
  * @param layout_info The layout info of the dynamic array.
  * @param base        The base type of the dynamic array.
  * @return The dynamic array type.
  */
  internal proc get_or_make_type_dynamic_array(layout_info: Layout_Info, base: *Type) -> *Type {
    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);
    layout_modifier := layout_info.modifier;

    cached_dynamic_array := Type_Cached_Dynamic_Array{layout_modifier, base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.dynamic_arrays, cached_dynamic_array);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_array_or_slice(.Dynamic_Array, layout_modifier, base, 0, false);
    name := name_builder.to_string();

    type := self.make_type!(Type_Dynamic_Array)(.Dynamic_Array, name);
    type.size = layout_modifier == .None ? TYPE_METRICS[Type_Kind.Dynamic_Array].size : base.get_size();
    type.alignment = layout_modifier == .None ? TYPE_METRICS[Type_Kind.Dynamic_Array].alignment : base.get_alignment();
    type.base = base;
    type.layout_info = layout_info;
    set_flag(&type.flags, .Passed_As_Pointer);

    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.dynamic_arrays, cached_dynamic_array, cast(*Type) type);

    return cast(*Type) type;
  }

  /**
  * Gets a cached slice type or makes a new one.
  * 
  * @param layout_info The layout info of the slice.
  * @param base        The base type of the slice.
  * @return The slice type.
  */
  internal proc get_or_make_type_slice(layout_info: Layout_Info, base: *Type) -> *Type {
    is_uninstantiated_generic := has_flag(base.flags, .Uninstantiated_Generic);
    layout_modifier := layout_info.modifier;

    cached_slice := Type_Cached_Slice{layout_modifier, base, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.slices, cached_slice);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_array_or_slice(.Slice, layout_modifier, base, 0, false);
    name := name_builder.to_string();

    type := self.make_type!(Type_Slice)(.Slice, name);
    type.size = layout_modifier == .None ? TYPE_METRICS[Type_Kind.Slice].size : base.get_size();
    type.alignment = layout_modifier == .None ? TYPE_METRICS[Type_Kind.Slice].alignment : base.get_alignment();
    type.base = base;
    type.layout_info = layout_info;
    set_flag(&type.flags, .Passed_As_Pointer);

    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.slices, cached_slice, cast(*Type) type);

    return cast(*Type) type;
  }

  /**
  * Gets a cached map type or makes a new one.
  * 
  * @param key   The key type of the map.
  * @param value The value type of the map.
  * @return The map type.
  */
  internal proc get_or_make_type_map(key: *Type, value: *Type) -> *Type {
    is_uninstantiated_generic := has_flag(key.flags, .Uninstantiated_Generic) || has_flag(value.flags, .Uninstantiated_Generic);

    cached_map := Type_Cached_Map{key, value, is_uninstantiated_generic};
    cached_type, found := map_get(&self.cache.maps, cached_map);
    if (found) then return cached_type;

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_map(key, value);
    name := name_builder.to_string();
  
    type := self.make_type!(Type_Map)(.Map, name);
    type.size = TYPE_METRICS[Type_Kind.Map].size;
    type.alignment = TYPE_METRICS[Type_Kind.Map].alignment;
    type.key = key;
    type.value = value;
    set_flag(&type.flags, .Passed_As_Pointer);

    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.maps, cached_map, cast(*Type) type);

    return cast(*Type) type;
  }

  /**
  * Gets a cached tuple type or makes a new one.
  * 
  * @param elements The elements of the tuple.
  * @return The tuple type.
  */
  internal proc get_or_make_type_tuple(elements: aosoa[dynamic]Type_Tuple_Element) -> *Type {
    is_uninstantiated_generic := false;
    foreach (element in elements) {
      if (has_flag(element.type.flags, .Uninstantiated_Generic)) {
        is_uninstantiated_generic = true;
        break;
      }
    }

    foreach (cached_tuple in self.cache.tuples) {
      if (cached_tuple.is_uninstantiated_generic != is_uninstantiated_generic) then continue;
      if (length(cached_tuple.elements) != length(elements)) then continue;
      has_same_elements := true;
      foreach (cached_element, i in cached_tuple.elements) {
        if (cached_element.type != elements[i].type) {
          has_same_elements = false;
          break;
        }
      }
      if (!has_same_elements) then continue;
      elements := elements;
      array_aosoa_destroy(&elements);
      return cached_tuple.tuple;
    }

    name_builder := strings.builder_make(self.name_allocator);
    name_builder.write_type_name_tuple(elements);
    name := name_builder.to_string();

    type := self.make_type!(Type_Tuple)(.Tuple, name);
    self.complete_type_tuple(cast(*Type) type, elements);

    if (is_uninstantiated_generic) then set_flag(&type.flags, .Uninstantiated_Generic);

    array_add(&self.cache.tuples, {elements, is_uninstantiated_generic, cast(*Type) type});

    return cast(*Type) type;
  }

  /**
  * Gets a cached routine type or makes a new one.
  * 
  * @param kind               The kind of the routine.
  * @param calling_convention The calling convention of the routine.
  * @param parameters         The parameters of the routine.
  * @param return_type        The return type of the routine.
  * @param routine_flags      The flags of the routine.
  * @return The routine type.
  */
  internal proc get_or_make_type_routine(
    kind: Type_Kind,
    calling_convention: Calling_Convention,
    parameters: aosoa[dynamic]Type_Routine_Parameter,
    return_type: *Type,
    routine_flags: Type_Routine_Flags,
  ) -> *Type {
    assert(kind == .Procedure || kind == .Function);

    is_uninstantiated_generic := false;
    foreach (parameter in parameters) {
      if (has_flag(parameter.type.flags, .Uninstantiated_Generic)) {
        break;
      }
    }
    if (has_flag(return_type.flags, .Uninstantiated_Generic)) {
      is_uninstantiated_generic = true;
    }

    cache_collection := kind == .Procedure ? &self.cache.procedures : &self.cache.functions;
    cached_type := self.get_cached_type_routine(cache_collection, calling_convention, parameters, return_type, routine_flags, is_uninstantiated_generic);
    if (cached_type != null) {
      // If we have found a cached function, we need to free the parameters being passed in as we do not need them anymore.
      parameters := parameters;
      array_aosoa_destroy(&parameters);
      return cached_type;
    }

    type := self.make_type_routine(kind, calling_convention, parameters, return_type, routine_flags);
    array_add(cache_collection, {calling_convention, parameters, return_type, routine_flags, is_uninstantiated_generic, type});

    return type;
  }

  /**
  * Gets or makes a new generic type.
  * 
  * @param storage The reference to the type storage.
  * @param name    The name of the generic.
  * @return The generic type.
  */
  internal proc get_or_make_type_generic(name: string) -> *Type {
    cached_generic_type := Type_Cached_Generic{name};
    cached_type, found := map_get(&self.cache.generics, cached_generic_type);
    if (found) then return cached_type;

    type := self.make_type!(Type)(.Generic, name);
    set_flag(&type.flags, .Uninstantiated_Generic);

    map_set(&self.cache.generics, cached_generic_type, type);

    return type;
  }

  /**
  * Completes a struct type.
  * 
  * @param type        The struct type to complete.
  * @param fields      The fields of the struct.
  * @param layout_info The layout info of the struct.
  */
  internal proc complete_type_struct(type: *Type, fields: aosoa[dynamic]Type_Struct_Field, layout_info: Layout_Info) {
    assert(type.is_struct());
    type_struct := cast(*Type_Struct) type;

    type_struct.size = 0;
    type_struct.alignment = 1;
    field_size_sum: uint = 0;

    // The structs starts of with having a hasher and comparer function.
    flags: Type_Flags;
    set_flag(&flags, .Passed_As_Pointer);
    set_flag(&flags, .Has_Hash_Function);
    set_flag(&flags, .Has_Compare_Function);

    for (i := 0; i < length(fields); i++) {
      field_type := fields[i].type;
      field_type_size := field_type.get_size();
      field_type_alignment := field_type.get_alignment();

      fields[i].offset = align_up(type_struct.size, field_type_alignment);

      type_struct.alignment = max(type_struct.alignment, field_type_alignment);
      type_struct.size = field_type_size + align_up(type_struct.size, field_type_alignment);

      field_size_sum += field_type_size;

      if (field_type.contains_self_relative_pointer_in_value()) {
        set_flag(&flags, .Not_Allowed_As_Union);
        set_flag(&flags, .Contains_Self_Relative_Pointer_In_Value);
        set_flag(&flags, .Requires_Address_Load);
      }
      if (!has_flag(field_type.flags, .Has_Hash_Function)) {
        remove_flag(&flags, .Has_Hash_Function);
      }
      if (!has_flag(field_type.flags, .Has_Compare_Function)) {
        remove_flag(&flags, .Has_Compare_Function);
      }
    }

    type_struct.size = align_up(type_struct.size, type_struct.alignment);
    type_struct.fields = fields;
    type_struct.layout_info = layout_info;
    set_flag(&type_struct.flags, flags);
  }

  /**
  * Completes a union type.
  * 
  * @param type     The union type to complete.
  * @param variants The variants of the union.
  */
  internal proc complete_type_union(type: *Type, variants: [dynamic]*Type) {
    assert(type.is_union());
    type_union := cast(*Type_Union) type;

    biggest_type: *Type;
    foreach (variant in variants) {
      if (biggest_type == null || biggest_type.size < variant.get_size()) {
        biggest_type = variant;
      }
    }

    // A union always has a 'tag' of type 'int' as an additional first member.
    type_union.size = TYPE_METRICS[Type_Kind.Int].size;
    type_union.alignment = TYPE_METRICS[Type_Kind.Int].alignment;
    if (biggest_type != null) {
      type_union.size += biggest_type.get_size();
      type_union.alignment = max(type_union.alignment, biggest_type.get_alignment());
    }

    type_union.variants = variants;
    type_union.biggest_type = biggest_type;
    set_flag(&type_union.flags, .Passed_As_Pointer);
    set_flag(&type_union.flags, .Requires_Address_Load);
  }

  /**
  * Completes a tuple type.
  * 
  * @param type     The tuple type to complete.
  * @param elements The elements of the tuple.
  */
  internal proc complete_type_tuple(type: *Type, elements: aosoa[dynamic]Type_Tuple_Element) {
    assert(type.is_tuple());
    type_tuple := cast(*Type_Tuple) type;

    type_tuple.size = 0;
    type_tuple.alignment = 1;
    element_size_sum: uint = 0;

    for (i := 0; i < length(elements); i++) {
      elements[i].offset = cast(uint) type_tuple.size;

      element_type := elements[i].type;
      element_type_size := element_type.get_size();
      element_type_alignment := element_type.get_alignment();

      type_tuple.alignment = max(type_tuple.alignment, element_type_alignment);
      type_tuple.size = element_type_size + align_up(type_tuple.size, element_type_alignment);

      element_size_sum += element_type_size;

      if (element_type.contains_self_relative_pointer_in_value()) {
        set_flag(&type_tuple.flags, .Not_Allowed_As_Union);
        set_flag(&type_tuple.flags, .Contains_Self_Relative_Pointer_In_Value);
        set_flag(&type_tuple.flags, .Requires_Address_Load);
      }
    }

    type_tuple.size = align_up(type_tuple.size, type_tuple.alignment);
    type_tuple.elements = elements;
    set_flag(&type_tuple.flags, .Passed_As_Pointer);
  }

  /**
  * Gets a cached routine type.
  * 
  * @param cache_collection          The collection holding the cached types.
  * @param calling_convention        The calling convention of the routine.
  * @param parameters                The parameters of the routine.
  * @param return_type               The return type of the routine.
  * @param routine_flags             The flags of the routine.
  * @param is_uninstantiated_generic Is the routine an uninstanted generic?
  * @return The cached routine type (or null if not cached).
  */
  internal proc get_cached_type_routine(
    cache_collection: *[dynamic]Type_Cached_Routine,
    calling_convention: Calling_Convention,
    parameters: aosoa[dynamic]Type_Routine_Parameter,
    return_type: *Type,
    routine_flags: Type_Routine_Flags,
    is_uninstantiated_generic: bool,
  ) -> *Type {
    foreach (cached_routine in cache_collection) {
      if (cached_routine.calling_convention != calling_convention) then continue;
      if (cached_routine.return_type != return_type) then continue;
      if (cached_routine.routine_flags != routine_flags) then continue;
      if (cached_routine.is_uninstantiated_generic != is_uninstantiated_generic) then continue;

      if (length(cached_routine.parameters) != length(parameters)) then continue;
      has_same_parameters := true;
      foreach (cached_parameter, i in cached_routine.parameters) {
        if (cached_parameter.type != parameters[i].type) {
          has_same_parameters = false;
          break;
        }
        if (cached_parameter.is_default != parameters[i].is_default) {
          has_same_parameters = false;
          break;
        }
      }
      if (!has_same_parameters) then continue;

      return cached_routine.routine;
    }

    return null;
  }

  /**
  * Gets a cached instantiated type.
  * 
  * @param uninstantiated_symbol The symbol defining the uninstantiated type.
  * @param generic_types         The generic types of the instantiated type.
  * @return The cached instantiated type (or null if not cached).
  */
  internal proc get_cached_type_instantiated(uninstantiated_type: *Type, generic_types: [dynamic]*Type) -> *Type {
    cached_instantiated_types, found := map_get(&self.cache.instantiated, uninstantiated_type);
    if (found) {
      foreach (cached_instantiated_type in cached_instantiated_types) {
        assert(length(cached_instantiated_type.generic_types) == length(generic_types));
        has_same_generic_types := true;
        foreach (generic_type, i in cached_instantiated_type.generic_types) {
          if (generic_type != generic_types[i]) {
            has_same_generic_types = false;
            break;
          }
        }
        if (!has_same_generic_types) then continue;
        return cached_instantiated_type.instantiated_type;
      }
    }
    return null;
  }

  /**
  * Gets a cached layout struct type.
  * 
  * @param collection_type    The collection type the layout struct is used in.
  * @param base_struct        The base struct of the layout struct.
  * @param layout_modifier    The layout modifier of the layout struct.
  * @param number_of_elements The number of elements (Only applicable for a fixed array collection).
  * @return The cached layout struct type (or null if not cached).
  */
  internal proc get_cached_type_layout_struct(
    collection_type: Collection_Type,
    base_struct: *Type,
    layout_modifier: Layout_Modifier,
    number_of_elements: int,
  ) -> *Type {
    cached_layout_struct := Type_Cached_Layout_Struct{collection_type, base_struct, layout_modifier, number_of_elements};
    cached_type, _ := map_get(&self.cache.layout_structs, cached_layout_struct);
    return cached_type;
  }

  /**
  * Calculates the number of items in an AoSoA chunk for a given struct type.
  *
  * @param type The struct type to calculate the number of items in an AoSoA chunk for.
  * @return 1. The number of items in an AoSoA chunk or -1 if th chunk is too big. 2. The field that is too big if the number of items is -1.
  */
  internal proc calculate_items_in_aosoa_chunk(type: *Type) -> (int, Type_Struct_Field) {
    assert(type.is_struct());

    type_struct := cast(*Type_Struct) type;

    // To calculate the maximum number of items we can fit in the chunk we have to find field with the biggest field.
    biggest_field: Type_Struct_Field;
    foreach (field in type_struct.fields) {
      field_type_size := field.type.get_size();
      if (biggest_field.type == null || field_type_size > biggest_field.type.get_size()) {
        biggest_field = *field;
      }
    }

    // The mimium size will always be at least 1.
    // This is so we can properly handle emtpy structs. 
    size_of_biggest_field: uint = 1;
    if (biggest_field.type != null) {
      size_of_biggest_field = biggest_field.type.get_size();
    }

    if (size_of_biggest_field > L1_CACHE_LINE_SIZE) {
       // Here we know that the struct has a field whose size exceeds the limit of an AoSoA chunk.
      return {-1, biggest_field};
    } else {
      return {cast(int) (L1_CACHE_LINE_SIZE / size_of_biggest_field), biggest_field};
    }
  }

}

/**
* Align size up based on current size and given alignment.
*
* @param size      The current size.
* @param alignment The alignement to use.
* @return The aligned size.
*/
private proc align_up(size: uint, alignment: uint) -> uint {
  return align_down(size + alignment - 1, alignment);
}

/**
* Align size down based on current size and given alignment.
*
* @param size      The current size.
* @param alignment The alignement to use.
* @return The aligned size.
*/
private proc align_down(size: uint, alignment: uint) -> uint {
  return size & ~(alignment - 1);
}

implement strings.Builder {

  /**
  * Writes a pointer type to the string builder.
  *
  * @param kind          The kind of the type.
  * @param base          The base type of the pointer type.
  * @param relative_base The relative base of the relative pointer type.
  */
  internal proc write_type_name_pointer(kind: Type_Kind, base: *Type, relative_base: *Type) {
    if (kind == .Self_Relative_Pointer) {
      self.write_string("~");
      self.write_string(relative_base.name);
    } else if (kind == .Offset_Relative_Pointer) {
      self.write_string("^");
      self.write_string(relative_base.name);
    } else if (kind == .Dynamic_Pointer) {
      self.write_string("dynamic");
    } else if (kind == .SoA_Layout_Pointer) {
      self.write_string("soa");
    } else if (kind == .AoSoA_Layout_Pointer) {
      self.write_string("aosoa");
    }

    self.write_string("*");
    self.write_string(base.name);
  }

  /**
  * Writes an array or slice type to the string builder.
  *
  * @param kind                    The kind of the type.
  * @param layout_modifier         The layout modifier of the array or slice.
  * @param base                    The base type of the array or slice.
  * @param number_of_elements      The number of elements in the array.
  * @param has_incomplete_elements Has the array incomplete elements?
  */
  internal proc write_type_name_array_or_slice(
    kind: Type_Kind,
    layout_modifier: Layout_Modifier,
    base: *Type,
    number_of_elements: int,
    has_incomplete_elements: bool,
  ) {
    if (layout_modifier == .SoA) {
      self.write_string("soa");
    } else if (layout_modifier == .AoSoA) {
      self.write_string("aosoa");
    }
    self.write_string("[");
    if (has_incomplete_elements) {
      self.write_string("...");
    } else if (kind == .Array) {
      self.write_uint(cast(uint) number_of_elements);
    } else if (kind == .Dynamic_Array) {
      self.write_string("dynamic");
    }
    self.write_string("]");
    self.write_string(base.name);
  } 

  /**
  * Writes a map type to the string builder.
  *
  * @param key   The key type of the map.
  * @param value The value type of the map.
  */
  internal proc write_type_name_map(key: *Type, value: *Type) {
    self.write_string("map[");
    self.write_string(key.name);
    self.write_string("]");
    self.write_string(value.name);
  }

  /**
  * Writes a tuple type to the string builder.
  *
  * @param elements The elements of the tuple.
  */
  internal proc write_type_name_tuple(elements: aosoa[dynamic]Type_Tuple_Element) {
    self.write_string("(");
    foreach (element, i in elements) {
      self.write_string(element.type.name);
      if (i < length(elements) - 1) {
        self.write_string(", ");
      }
    }
    self.write_string(")");
  }

  /**
  * Writes a struct with a name to the string builder.
  *
  * @param name          The name of the struct.
  * @param generic_types The generic types of the struct.
  */
  internal proc write_type_name_struct(name: string, generic_types: [dynamic]*Type) {
    self.write_string(name);
    if (length(generic_types) > 0) {
      self.write_string("!(");
      foreach (generic_type, i in generic_types) {
        self.write_string(generic_type.name);
        if (i < length(generic_types) - 1) {
          self.write_string(", ");
        }
      }
      self.write_string(")");
    }
  }

  /**
  * Writes a routine type with a name to the string builder.
  *
  * @param type The routine type to write.
  * @param name The name of the routine to include.
  */
  internal proc write_type_name_routine(type: *Type, name: string) {
    assert(type.kind == .Procedure || type.kind == .Function);
    type := cast(*Type_Routine) type;

    self.write_type_name_routine_raw(
      type.kind,
      type.calling_convention,
      type.parameters,
      type.return_type,
      type.routine_flags,
      name,
    );
  }

  /**
  * Writes a routine type with a name to the string builder.
  *
  * @param kind               The kind of the routine.
  * @param calling_convention The calling convention of the routine.
  * @param parameters         The parameters of the routine.
  * @param return_type        The return type of the routine.
  * @param flags              The flags of the routine.
  * @param name               The name of the routine to include.
  */
  internal proc write_type_name_routine_raw(
    kind: Type_Kind,
    calling_convention: Calling_Convention,
    parameters: aosoa[dynamic]Type_Routine_Parameter,
    return_type: *Type,
    routine_flags: Type_Routine_Flags,
    name: string
  ) {
    if (has_flag(routine_flags, .Is_Intrinsic)) {
      self.write_string("@intrinsic ");
    } else if (has_flag(routine_flags, .Is_Method)) {
      self.write_string("@method ");
    }

    if (has_flag(routine_flags, .Is_Pure_Function)) {
      self.write_string("pure ");
    }
    self.write_string(kind == .Procedure ? "proc" : "func");

    switch (calling_convention) {
      case .Nox: // We omit the defalt calling convention.
      case .No_Context: self.write_string(" \"nocontext\" ");
      case .C: self.write_string(" \"c\" ");
      case .Std_Call: self.write_string(" \"stdcall\" ");
      case .Fast_Call: self.write_string(" \"fastcall\" ");
      case .Win64: self.write_string(" \"win64\" ");
    }

    if (name != "") {
      self.write_string(" ");
      self.write_string(name);
    }

    self.write_string("(");
    foreach (parameter, i in parameters) {
      if (has_flag(routine_flags, .Has_Params) && i == length(parameters) - 1) {
        self.write_string("params ");
      }
      self.write_string(parameter.type.name);
      if (i < length(parameters) - 1 || has_flag(routine_flags, .Has_C_Varargs)) {
        self.write_string(", ");
      }
    }
    if (has_flag(routine_flags, .Has_C_Varargs)) {
      self.write_string("...");
    }
    self.write_string(")");

    if (return_type != null && !return_type.is_void()) {
      self.write_string(" -> ");
      self.write_string(return_type.name);
    }
  }

}

/**
* Writes a all names of given types as a list.
*
* @param types The types whose names to write.
* @return The final list of names.
*/
internal proc get_type_names(types: [dynamic]*Type) -> string {
  builder := strings.builder_make(context.temporary_allocator);
  foreach (type, i in types) {
    builder.write_string("    ");
    builder.write_string(type.name);
    if (i < length(types) - 1) {
      builder.write_string("\n");
    }
  }
  return builder.to_string();
}

/**
* Makes routine flags for a routine type.
* @param has_params    Has the routine a 'params' parameter?
* @param has_c_varargs Has the routine an c varargs parameter?
* @param is_intrinsic  Is the routine an intrinsic?
* @param is_method     Is the routine a method?
* @param is_pure       Is the routine a pure function?
* @return The routine flags.
*/
internal proc make_routine_flags(has_params: bool, has_c_varargs: bool, is_intrinsic: bool, is_method: bool, is_pure: bool) -> Type_Routine_Flags {
  routine_flags: Type_Routine_Flags;
  if (has_params) {
    set_flag(&routine_flags, .Has_Params);
  }
  if (has_c_varargs) {
    set_flag(&routine_flags, .Has_C_Varargs);
  }
  if (is_intrinsic) {
    set_flag(&routine_flags, .Is_Intrinsic);
  }
  if (is_method) {
    set_flag(&routine_flags, .Is_Method);
  }
  if (is_pure) {
    set_flag(&routine_flags, .Is_Pure_Function);
  }
  return routine_flags;
}
